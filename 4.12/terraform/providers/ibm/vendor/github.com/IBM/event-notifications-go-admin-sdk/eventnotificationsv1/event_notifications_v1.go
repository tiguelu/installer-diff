/**
 * (C) Copyright IBM Corp. 2022.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*
 * IBM OpenAPI SDK Code Generator Version: 3.46.0-a4e29da0-20220224-210428
 */

// Package eventnotificationsv1 : Operations and models for the EventNotificationsV1 service
package eventnotificationsv1

import (
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"reflect"
	"time"

	common "github.com/IBM/event-notifications-go-admin-sdk/common"
	"github.com/IBM/go-sdk-core/v5/core"
	"github.com/go-openapi/strfmt"
)

// EventNotificationsV1 : No description provided (generated by Openapi Generator
// https://github.com/openapitools/openapi-generator)
//
// API Version: 1.0
type EventNotificationsV1 struct {
	Service *core.BaseService
}

// DefaultServiceURL is the default URL to make service requests to.
const DefaultServiceURL = "https://us-south.event-notifications.cloud.ibm.com/event-notifications"

// DefaultServiceName is the default key used to find external configuration information.
const DefaultServiceName = "event_notifications"

// EventNotificationsV1Options : Service options
type EventNotificationsV1Options struct {
	ServiceName   string
	URL           string
	Authenticator core.Authenticator
}

// NewEventNotificationsV1UsingExternalConfig : constructs an instance of EventNotificationsV1 with passed in options and external configuration.
func NewEventNotificationsV1UsingExternalConfig(options *EventNotificationsV1Options) (eventNotifications *EventNotificationsV1, err error) {
	if options.ServiceName == "" {
		options.ServiceName = DefaultServiceName
	}

	if options.Authenticator == nil {
		options.Authenticator, err = core.GetAuthenticatorFromEnvironment(options.ServiceName)
		if err != nil {
			return
		}
	}

	eventNotifications, err = NewEventNotificationsV1(options)
	if err != nil {
		return
	}

	err = eventNotifications.Service.ConfigureService(options.ServiceName)
	if err != nil {
		return
	}

	if options.URL != "" {
		err = eventNotifications.Service.SetServiceURL(options.URL)
	}
	return
}

// NewEventNotificationsV1 : constructs an instance of EventNotificationsV1 with passed in options.
func NewEventNotificationsV1(options *EventNotificationsV1Options) (service *EventNotificationsV1, err error) {
	serviceOptions := &core.ServiceOptions{
		URL:           DefaultServiceURL,
		Authenticator: options.Authenticator,
	}

	baseService, err := core.NewBaseService(serviceOptions)
	if err != nil {
		return
	}

	if options.URL != "" {
		err = baseService.SetServiceURL(options.URL)
		if err != nil {
			return
		}
	}

	service = &EventNotificationsV1{
		Service: baseService,
	}

	return
}

// GetServiceURLForRegion returns the service URL to be used for the specified region
func GetServiceURLForRegion(region string) (string, error) {
	return "", fmt.Errorf("service does not support regional URLs")
}

// Clone makes a copy of "eventNotifications" suitable for processing requests.
func (eventNotifications *EventNotificationsV1) Clone() *EventNotificationsV1 {
	if core.IsNil(eventNotifications) {
		return nil
	}
	clone := *eventNotifications
	clone.Service = eventNotifications.Service.Clone()
	return &clone
}

// SetServiceURL sets the service URL
func (eventNotifications *EventNotificationsV1) SetServiceURL(url string) error {
	return eventNotifications.Service.SetServiceURL(url)
}

// GetServiceURL returns the service URL
func (eventNotifications *EventNotificationsV1) GetServiceURL() string {
	return eventNotifications.Service.GetServiceURL()
}

// SetDefaultHeaders sets HTTP headers to be sent in every request
func (eventNotifications *EventNotificationsV1) SetDefaultHeaders(headers http.Header) {
	eventNotifications.Service.SetDefaultHeaders(headers)
}

// SetEnableGzipCompression sets the service's EnableGzipCompression field
func (eventNotifications *EventNotificationsV1) SetEnableGzipCompression(enableGzip bool) {
	eventNotifications.Service.SetEnableGzipCompression(enableGzip)
}

// GetEnableGzipCompression returns the service's EnableGzipCompression field
func (eventNotifications *EventNotificationsV1) GetEnableGzipCompression() bool {
	return eventNotifications.Service.GetEnableGzipCompression()
}

// EnableRetries enables automatic retries for requests invoked for this service instance.
// If either parameter is specified as 0, then a default value is used instead.
func (eventNotifications *EventNotificationsV1) EnableRetries(maxRetries int, maxRetryInterval time.Duration) {
	eventNotifications.Service.EnableRetries(maxRetries, maxRetryInterval)
}

// DisableRetries disables automatic retries for requests invoked for this service instance.
func (eventNotifications *EventNotificationsV1) DisableRetries() {
	eventNotifications.Service.DisableRetries()
}

// SendNotifications : Send a notification
func (eventNotifications *EventNotificationsV1) SendNotifications(sendNotificationsOptions *SendNotificationsOptions) (result *NotificationResponse, response *core.DetailedResponse, err error) {
	return eventNotifications.SendNotificationsWithContext(context.Background(), sendNotificationsOptions)
}

// SendNotificationsWithContext is an alternate form of the SendNotifications method which supports a Context parameter
func (eventNotifications *EventNotificationsV1) SendNotificationsWithContext(ctx context.Context, sendNotificationsOptions *SendNotificationsOptions) (result *NotificationResponse, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(sendNotificationsOptions, "sendNotificationsOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(sendNotificationsOptions, "sendNotificationsOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"instance_id": *sendNotificationsOptions.InstanceID,
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = eventNotifications.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(eventNotifications.Service.Options.URL, `/v1/instances/{instance_id}/notifications`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range sendNotificationsOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("event_notifications", "V1", "SendNotifications")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")
	if sendNotificationsOptions.CeIbmenseverity != nil {
		builder.AddHeader("ce-ibmenseverity", fmt.Sprint(*sendNotificationsOptions.CeIbmenseverity))
	}
	if sendNotificationsOptions.CeIbmendefaultshort != nil {
		builder.AddHeader("ce-ibmendefaultshort", fmt.Sprint(*sendNotificationsOptions.CeIbmendefaultshort))
	}
	if sendNotificationsOptions.CeIbmendefaultlong != nil {
		builder.AddHeader("ce-ibmendefaultlong", fmt.Sprint(*sendNotificationsOptions.CeIbmendefaultlong))
	}
	if sendNotificationsOptions.CeIbmenfcmbody != nil {
		builder.AddHeader("ce-ibmenfcmbody", fmt.Sprint(*sendNotificationsOptions.CeIbmenfcmbody))
	}
	if sendNotificationsOptions.CeIbmenapnsbody != nil {
		builder.AddHeader("ce-ibmenapnsbody", fmt.Sprint(*sendNotificationsOptions.CeIbmenapnsbody))
	}
	if sendNotificationsOptions.CeIbmensafaribody != nil {
		builder.AddHeader("ce-ibmensafaribody", fmt.Sprint(*sendNotificationsOptions.CeIbmensafaribody))
	}
	if sendNotificationsOptions.CeIbmenpushto != nil {
		builder.AddHeader("ce-ibmenpushto", fmt.Sprint(*sendNotificationsOptions.CeIbmenpushto))
	}
	if sendNotificationsOptions.CeIbmenapnsheaders != nil {
		builder.AddHeader("ce-ibmenapnsheaders", fmt.Sprint(*sendNotificationsOptions.CeIbmenapnsheaders))
	}
	if sendNotificationsOptions.CeIbmenchromebody != nil {
		builder.AddHeader("ce-ibmenchromebody", fmt.Sprint(*sendNotificationsOptions.CeIbmenchromebody))
	}
	if sendNotificationsOptions.CeIbmenfirefoxbody != nil {
		builder.AddHeader("ce-ibmenfirefoxbody", fmt.Sprint(*sendNotificationsOptions.CeIbmenfirefoxbody))
	}
	if sendNotificationsOptions.CeIbmenchromeheaders != nil {
		builder.AddHeader("ce-ibmenchromeheaders", fmt.Sprint(*sendNotificationsOptions.CeIbmenchromeheaders))
	}
	if sendNotificationsOptions.CeIbmenfirefoxheaders != nil {
		builder.AddHeader("ce-ibmenfirefoxheaders", fmt.Sprint(*sendNotificationsOptions.CeIbmenfirefoxheaders))
	}
	if sendNotificationsOptions.CeIbmensourceid != nil {
		builder.AddHeader("ce-ibmensourceid", fmt.Sprint(*sendNotificationsOptions.CeIbmensourceid))
	}
	if sendNotificationsOptions.CeID != nil {
		builder.AddHeader("ce-id", fmt.Sprint(*sendNotificationsOptions.CeID))
	}
	if sendNotificationsOptions.CeSource != nil {
		builder.AddHeader("ce-source", fmt.Sprint(*sendNotificationsOptions.CeSource))
	}
	if sendNotificationsOptions.CeType != nil {
		builder.AddHeader("ce-type", fmt.Sprint(*sendNotificationsOptions.CeType))
	}
	if sendNotificationsOptions.CeSpecversion != nil {
		builder.AddHeader("ce-specversion", fmt.Sprint(*sendNotificationsOptions.CeSpecversion))
	}
	if sendNotificationsOptions.CeTime != nil {
		builder.AddHeader("ce-time", fmt.Sprint(*sendNotificationsOptions.CeTime))
	}

	if sendNotificationsOptions.Body != nil {
		_, err = builder.SetBodyContentJSON(sendNotificationsOptions.Body)
		if err != nil {
			return
		}
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = eventNotifications.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalNotificationResponse)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// SendBulkNotifications : Send Bulk notification
func (eventNotifications *EventNotificationsV1) SendBulkNotifications(sendBulkNotificationsOptions *SendBulkNotificationsOptions) (result *BulkNotificationResponse, response *core.DetailedResponse, err error) {
	return eventNotifications.SendBulkNotificationsWithContext(context.Background(), sendBulkNotificationsOptions)
}

// SendBulkNotificationsWithContext is an alternate form of the SendBulkNotifications method which supports a Context parameter
func (eventNotifications *EventNotificationsV1) SendBulkNotificationsWithContext(ctx context.Context, sendBulkNotificationsOptions *SendBulkNotificationsOptions) (result *BulkNotificationResponse, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(sendBulkNotificationsOptions, "sendBulkNotificationsOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(sendBulkNotificationsOptions, "sendBulkNotificationsOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"instance_id": *sendBulkNotificationsOptions.InstanceID,
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = eventNotifications.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(eventNotifications.Service.Options.URL, `/v1/instances/{instance_id}/notifications/bulk`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range sendBulkNotificationsOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("event_notifications", "V1", "SendBulkNotifications")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	body := make(map[string]interface{})
	if sendBulkNotificationsOptions.BulkMessages != nil {
		body["bulk_messages"] = sendBulkNotificationsOptions.BulkMessages
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = eventNotifications.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalBulkNotificationResponse)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// CreateSources : Create a new API Source
// Create a new API Source.
func (eventNotifications *EventNotificationsV1) CreateSources(createSourcesOptions *CreateSourcesOptions) (result *SourceResponse, response *core.DetailedResponse, err error) {
	return eventNotifications.CreateSourcesWithContext(context.Background(), createSourcesOptions)
}

// CreateSourcesWithContext is an alternate form of the CreateSources method which supports a Context parameter
func (eventNotifications *EventNotificationsV1) CreateSourcesWithContext(ctx context.Context, createSourcesOptions *CreateSourcesOptions) (result *SourceResponse, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(createSourcesOptions, "createSourcesOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(createSourcesOptions, "createSourcesOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"instance_id": *createSourcesOptions.InstanceID,
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = eventNotifications.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(eventNotifications.Service.Options.URL, `/v1/instances/{instance_id}/sources`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range createSourcesOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("event_notifications", "V1", "CreateSources")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	body := make(map[string]interface{})
	if createSourcesOptions.Name != nil {
		body["name"] = createSourcesOptions.Name
	}
	if createSourcesOptions.Description != nil {
		body["description"] = createSourcesOptions.Description
	}
	if createSourcesOptions.Enabled != nil {
		body["enabled"] = createSourcesOptions.Enabled
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = eventNotifications.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalSourceResponse)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// ListSources : List all Sources
// List all Sources.
func (eventNotifications *EventNotificationsV1) ListSources(listSourcesOptions *ListSourcesOptions) (result *SourceList, response *core.DetailedResponse, err error) {
	return eventNotifications.ListSourcesWithContext(context.Background(), listSourcesOptions)
}

// ListSourcesWithContext is an alternate form of the ListSources method which supports a Context parameter
func (eventNotifications *EventNotificationsV1) ListSourcesWithContext(ctx context.Context, listSourcesOptions *ListSourcesOptions) (result *SourceList, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(listSourcesOptions, "listSourcesOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(listSourcesOptions, "listSourcesOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"instance_id": *listSourcesOptions.InstanceID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = eventNotifications.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(eventNotifications.Service.Options.URL, `/v1/instances/{instance_id}/sources`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range listSourcesOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("event_notifications", "V1", "ListSources")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	if listSourcesOptions.Limit != nil {
		builder.AddQuery("limit", fmt.Sprint(*listSourcesOptions.Limit))
	}
	if listSourcesOptions.Offset != nil {
		builder.AddQuery("offset", fmt.Sprint(*listSourcesOptions.Offset))
	}
	if listSourcesOptions.Search != nil {
		builder.AddQuery("search", fmt.Sprint(*listSourcesOptions.Search))
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = eventNotifications.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalSourceList)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// GetSource : Get a Source
// Get a Sources.
func (eventNotifications *EventNotificationsV1) GetSource(getSourceOptions *GetSourceOptions) (result *Source, response *core.DetailedResponse, err error) {
	return eventNotifications.GetSourceWithContext(context.Background(), getSourceOptions)
}

// GetSourceWithContext is an alternate form of the GetSource method which supports a Context parameter
func (eventNotifications *EventNotificationsV1) GetSourceWithContext(ctx context.Context, getSourceOptions *GetSourceOptions) (result *Source, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getSourceOptions, "getSourceOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getSourceOptions, "getSourceOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"instance_id": *getSourceOptions.InstanceID,
		"id":          *getSourceOptions.ID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = eventNotifications.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(eventNotifications.Service.Options.URL, `/v1/instances/{instance_id}/sources/{id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range getSourceOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("event_notifications", "V1", "GetSource")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = eventNotifications.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalSource)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// DeleteSource : Delete a Source
// Delete a Source.
func (eventNotifications *EventNotificationsV1) DeleteSource(deleteSourceOptions *DeleteSourceOptions) (response *core.DetailedResponse, err error) {
	return eventNotifications.DeleteSourceWithContext(context.Background(), deleteSourceOptions)
}

// DeleteSourceWithContext is an alternate form of the DeleteSource method which supports a Context parameter
func (eventNotifications *EventNotificationsV1) DeleteSourceWithContext(ctx context.Context, deleteSourceOptions *DeleteSourceOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(deleteSourceOptions, "deleteSourceOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(deleteSourceOptions, "deleteSourceOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"instance_id": *deleteSourceOptions.InstanceID,
		"id":          *deleteSourceOptions.ID,
	}

	builder := core.NewRequestBuilder(core.DELETE)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = eventNotifications.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(eventNotifications.Service.Options.URL, `/v1/instances/{instance_id}/sources/{id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range deleteSourceOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("event_notifications", "V1", "DeleteSource")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = eventNotifications.Service.Request(request, nil)

	return
}

// UpdateSource : Update details of a Source
// Update details of a Source.
func (eventNotifications *EventNotificationsV1) UpdateSource(updateSourceOptions *UpdateSourceOptions) (result *Source, response *core.DetailedResponse, err error) {
	return eventNotifications.UpdateSourceWithContext(context.Background(), updateSourceOptions)
}

// UpdateSourceWithContext is an alternate form of the UpdateSource method which supports a Context parameter
func (eventNotifications *EventNotificationsV1) UpdateSourceWithContext(ctx context.Context, updateSourceOptions *UpdateSourceOptions) (result *Source, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(updateSourceOptions, "updateSourceOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(updateSourceOptions, "updateSourceOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"instance_id": *updateSourceOptions.InstanceID,
		"id":          *updateSourceOptions.ID,
	}

	builder := core.NewRequestBuilder(core.PATCH)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = eventNotifications.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(eventNotifications.Service.Options.URL, `/v1/instances/{instance_id}/sources/{id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range updateSourceOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("event_notifications", "V1", "UpdateSource")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	body := make(map[string]interface{})
	if updateSourceOptions.Name != nil {
		body["name"] = updateSourceOptions.Name
	}
	if updateSourceOptions.Description != nil {
		body["description"] = updateSourceOptions.Description
	}
	if updateSourceOptions.Enabled != nil {
		body["enabled"] = updateSourceOptions.Enabled
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = eventNotifications.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalSource)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// CreateTopic : Create a new Topic
// Create a new Topic.
func (eventNotifications *EventNotificationsV1) CreateTopic(createTopicOptions *CreateTopicOptions) (result *TopicResponse, response *core.DetailedResponse, err error) {
	return eventNotifications.CreateTopicWithContext(context.Background(), createTopicOptions)
}

// CreateTopicWithContext is an alternate form of the CreateTopic method which supports a Context parameter
func (eventNotifications *EventNotificationsV1) CreateTopicWithContext(ctx context.Context, createTopicOptions *CreateTopicOptions) (result *TopicResponse, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(createTopicOptions, "createTopicOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(createTopicOptions, "createTopicOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"instance_id": *createTopicOptions.InstanceID,
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = eventNotifications.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(eventNotifications.Service.Options.URL, `/v1/instances/{instance_id}/topics`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range createTopicOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("event_notifications", "V1", "CreateTopic")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	body := make(map[string]interface{})
	if createTopicOptions.Name != nil {
		body["name"] = createTopicOptions.Name
	}
	if createTopicOptions.Description != nil {
		body["description"] = createTopicOptions.Description
	}
	if createTopicOptions.Sources != nil {
		body["sources"] = createTopicOptions.Sources
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = eventNotifications.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalTopicResponse)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// ListTopics : List all Topics
// List all Topics.
func (eventNotifications *EventNotificationsV1) ListTopics(listTopicsOptions *ListTopicsOptions) (result *TopicList, response *core.DetailedResponse, err error) {
	return eventNotifications.ListTopicsWithContext(context.Background(), listTopicsOptions)
}

// ListTopicsWithContext is an alternate form of the ListTopics method which supports a Context parameter
func (eventNotifications *EventNotificationsV1) ListTopicsWithContext(ctx context.Context, listTopicsOptions *ListTopicsOptions) (result *TopicList, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(listTopicsOptions, "listTopicsOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(listTopicsOptions, "listTopicsOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"instance_id": *listTopicsOptions.InstanceID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = eventNotifications.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(eventNotifications.Service.Options.URL, `/v1/instances/{instance_id}/topics`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range listTopicsOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("event_notifications", "V1", "ListTopics")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	if listTopicsOptions.Limit != nil {
		builder.AddQuery("limit", fmt.Sprint(*listTopicsOptions.Limit))
	}
	if listTopicsOptions.Offset != nil {
		builder.AddQuery("offset", fmt.Sprint(*listTopicsOptions.Offset))
	}
	if listTopicsOptions.Search != nil {
		builder.AddQuery("search", fmt.Sprint(*listTopicsOptions.Search))
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = eventNotifications.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalTopicList)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// GetTopic : Get details of a Topic
// Get details of a Topic.
func (eventNotifications *EventNotificationsV1) GetTopic(getTopicOptions *GetTopicOptions) (result *Topic, response *core.DetailedResponse, err error) {
	return eventNotifications.GetTopicWithContext(context.Background(), getTopicOptions)
}

// GetTopicWithContext is an alternate form of the GetTopic method which supports a Context parameter
func (eventNotifications *EventNotificationsV1) GetTopicWithContext(ctx context.Context, getTopicOptions *GetTopicOptions) (result *Topic, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getTopicOptions, "getTopicOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getTopicOptions, "getTopicOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"instance_id": *getTopicOptions.InstanceID,
		"id":          *getTopicOptions.ID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = eventNotifications.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(eventNotifications.Service.Options.URL, `/v1/instances/{instance_id}/topics/{id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range getTopicOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("event_notifications", "V1", "GetTopic")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	if getTopicOptions.Include != nil {
		builder.AddQuery("include", fmt.Sprint(*getTopicOptions.Include))
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = eventNotifications.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalTopic)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// ReplaceTopic : Update details of a Topic
// Update details of a Topic.
func (eventNotifications *EventNotificationsV1) ReplaceTopic(replaceTopicOptions *ReplaceTopicOptions) (result *Topic, response *core.DetailedResponse, err error) {
	return eventNotifications.ReplaceTopicWithContext(context.Background(), replaceTopicOptions)
}

// ReplaceTopicWithContext is an alternate form of the ReplaceTopic method which supports a Context parameter
func (eventNotifications *EventNotificationsV1) ReplaceTopicWithContext(ctx context.Context, replaceTopicOptions *ReplaceTopicOptions) (result *Topic, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(replaceTopicOptions, "replaceTopicOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(replaceTopicOptions, "replaceTopicOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"instance_id": *replaceTopicOptions.InstanceID,
		"id":          *replaceTopicOptions.ID,
	}

	builder := core.NewRequestBuilder(core.PUT)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = eventNotifications.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(eventNotifications.Service.Options.URL, `/v1/instances/{instance_id}/topics/{id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range replaceTopicOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("event_notifications", "V1", "ReplaceTopic")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	body := make(map[string]interface{})
	if replaceTopicOptions.Name != nil {
		body["name"] = replaceTopicOptions.Name
	}
	if replaceTopicOptions.Description != nil {
		body["description"] = replaceTopicOptions.Description
	}
	if replaceTopicOptions.Sources != nil {
		body["sources"] = replaceTopicOptions.Sources
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = eventNotifications.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalTopic)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// DeleteTopic : Delete a Topic
// Delete a Topic.
func (eventNotifications *EventNotificationsV1) DeleteTopic(deleteTopicOptions *DeleteTopicOptions) (response *core.DetailedResponse, err error) {
	return eventNotifications.DeleteTopicWithContext(context.Background(), deleteTopicOptions)
}

// DeleteTopicWithContext is an alternate form of the DeleteTopic method which supports a Context parameter
func (eventNotifications *EventNotificationsV1) DeleteTopicWithContext(ctx context.Context, deleteTopicOptions *DeleteTopicOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(deleteTopicOptions, "deleteTopicOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(deleteTopicOptions, "deleteTopicOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"instance_id": *deleteTopicOptions.InstanceID,
		"id":          *deleteTopicOptions.ID,
	}

	builder := core.NewRequestBuilder(core.DELETE)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = eventNotifications.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(eventNotifications.Service.Options.URL, `/v1/instances/{instance_id}/topics/{id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range deleteTopicOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("event_notifications", "V1", "DeleteTopic")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = eventNotifications.Service.Request(request, nil)

	return
}

// CreateDestination : Create a new Destination
// Create a new Destination.
func (eventNotifications *EventNotificationsV1) CreateDestination(createDestinationOptions *CreateDestinationOptions) (result *DestinationResponse, response *core.DetailedResponse, err error) {
	return eventNotifications.CreateDestinationWithContext(context.Background(), createDestinationOptions)
}

// CreateDestinationWithContext is an alternate form of the CreateDestination method which supports a Context parameter
func (eventNotifications *EventNotificationsV1) CreateDestinationWithContext(ctx context.Context, createDestinationOptions *CreateDestinationOptions) (result *DestinationResponse, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(createDestinationOptions, "createDestinationOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(createDestinationOptions, "createDestinationOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"instance_id": *createDestinationOptions.InstanceID,
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = eventNotifications.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(eventNotifications.Service.Options.URL, `/v1/instances/{instance_id}/destinations`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range createDestinationOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("event_notifications", "V1", "CreateDestination")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddFormData("name", "", "", fmt.Sprint(*createDestinationOptions.Name))
	builder.AddFormData("type", "", "", fmt.Sprint(*createDestinationOptions.Type))
	if createDestinationOptions.Description != nil {
		builder.AddFormData("description", "", "", fmt.Sprint(*createDestinationOptions.Description))
	}
	if createDestinationOptions.Config != nil {
		builder.AddFormData("config", "", "application/json", createDestinationOptions.Config)
	}
	if createDestinationOptions.Certificate != nil {
		builder.AddFormData("certificate", "",
			core.StringNilMapper(createDestinationOptions.CertificateContentType), createDestinationOptions.Certificate)
	}
	if createDestinationOptions.Icon16x16 != nil {
		builder.AddFormData("icon_16x16", "",
			core.StringNilMapper(createDestinationOptions.Icon16x16ContentType), createDestinationOptions.Icon16x16)
	}
	if createDestinationOptions.Icon16x162x != nil {
		builder.AddFormData("icon_16x16@2x", "",
			core.StringNilMapper(createDestinationOptions.Icon16x162xContentType), createDestinationOptions.Icon16x162x)
	}
	if createDestinationOptions.Icon32x32 != nil {
		builder.AddFormData("icon_32x32", "",
			core.StringNilMapper(createDestinationOptions.Icon32x32ContentType), createDestinationOptions.Icon32x32)
	}
	if createDestinationOptions.Icon32x322x != nil {
		builder.AddFormData("icon_32x32@2x", "",
			core.StringNilMapper(createDestinationOptions.Icon32x322xContentType), createDestinationOptions.Icon32x322x)
	}
	if createDestinationOptions.Icon128x128 != nil {
		builder.AddFormData("icon_128x128", "",
			core.StringNilMapper(createDestinationOptions.Icon128x128ContentType), createDestinationOptions.Icon128x128)
	}
	if createDestinationOptions.Icon128x1282x != nil {
		builder.AddFormData("icon_128x128@2x", "",
			core.StringNilMapper(createDestinationOptions.Icon128x1282xContentType), createDestinationOptions.Icon128x1282x)
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = eventNotifications.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalDestinationResponse)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// ListDestinations : List all Destinations
// List all Destinations.
func (eventNotifications *EventNotificationsV1) ListDestinations(listDestinationsOptions *ListDestinationsOptions) (result *DestinationList, response *core.DetailedResponse, err error) {
	return eventNotifications.ListDestinationsWithContext(context.Background(), listDestinationsOptions)
}

// ListDestinationsWithContext is an alternate form of the ListDestinations method which supports a Context parameter
func (eventNotifications *EventNotificationsV1) ListDestinationsWithContext(ctx context.Context, listDestinationsOptions *ListDestinationsOptions) (result *DestinationList, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(listDestinationsOptions, "listDestinationsOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(listDestinationsOptions, "listDestinationsOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"instance_id": *listDestinationsOptions.InstanceID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = eventNotifications.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(eventNotifications.Service.Options.URL, `/v1/instances/{instance_id}/destinations`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range listDestinationsOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("event_notifications", "V1", "ListDestinations")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	if listDestinationsOptions.Limit != nil {
		builder.AddQuery("limit", fmt.Sprint(*listDestinationsOptions.Limit))
	}
	if listDestinationsOptions.Offset != nil {
		builder.AddQuery("offset", fmt.Sprint(*listDestinationsOptions.Offset))
	}
	if listDestinationsOptions.Search != nil {
		builder.AddQuery("search", fmt.Sprint(*listDestinationsOptions.Search))
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = eventNotifications.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalDestinationList)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// GetDestination : Get details of a Destination
// Get details of a Destination.
func (eventNotifications *EventNotificationsV1) GetDestination(getDestinationOptions *GetDestinationOptions) (result *Destination, response *core.DetailedResponse, err error) {
	return eventNotifications.GetDestinationWithContext(context.Background(), getDestinationOptions)
}

// GetDestinationWithContext is an alternate form of the GetDestination method which supports a Context parameter
func (eventNotifications *EventNotificationsV1) GetDestinationWithContext(ctx context.Context, getDestinationOptions *GetDestinationOptions) (result *Destination, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getDestinationOptions, "getDestinationOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getDestinationOptions, "getDestinationOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"instance_id": *getDestinationOptions.InstanceID,
		"id":          *getDestinationOptions.ID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = eventNotifications.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(eventNotifications.Service.Options.URL, `/v1/instances/{instance_id}/destinations/{id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range getDestinationOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("event_notifications", "V1", "GetDestination")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = eventNotifications.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalDestination)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// UpdateDestination : Update details of a Destination
// Update details of a Destination.
func (eventNotifications *EventNotificationsV1) UpdateDestination(updateDestinationOptions *UpdateDestinationOptions) (result *Destination, response *core.DetailedResponse, err error) {
	return eventNotifications.UpdateDestinationWithContext(context.Background(), updateDestinationOptions)
}

// UpdateDestinationWithContext is an alternate form of the UpdateDestination method which supports a Context parameter
func (eventNotifications *EventNotificationsV1) UpdateDestinationWithContext(ctx context.Context, updateDestinationOptions *UpdateDestinationOptions) (result *Destination, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(updateDestinationOptions, "updateDestinationOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(updateDestinationOptions, "updateDestinationOptions")
	if err != nil {
		return
	}
	if (updateDestinationOptions.Name == nil) && (updateDestinationOptions.Description == nil) && (updateDestinationOptions.Config == nil) && (updateDestinationOptions.Certificate == nil) && (updateDestinationOptions.Icon16x16 == nil) && (updateDestinationOptions.Icon16x162x == nil) && (updateDestinationOptions.Icon32x32 == nil) && (updateDestinationOptions.Icon32x322x == nil) && (updateDestinationOptions.Icon128x128 == nil) && (updateDestinationOptions.Icon128x1282x == nil) {
		err = fmt.Errorf("at least one of name, description, config, certificate, icon16x16, icon16x162x, icon32x32, icon32x322x, icon128x128, or icon128x1282x must be supplied")
		return
	}

	pathParamsMap := map[string]string{
		"instance_id": *updateDestinationOptions.InstanceID,
		"id":          *updateDestinationOptions.ID,
	}

	builder := core.NewRequestBuilder(core.PATCH)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = eventNotifications.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(eventNotifications.Service.Options.URL, `/v1/instances/{instance_id}/destinations/{id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range updateDestinationOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("event_notifications", "V1", "UpdateDestination")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	if updateDestinationOptions.Name != nil {
		builder.AddFormData("name", "", "", fmt.Sprint(*updateDestinationOptions.Name))
	}
	if updateDestinationOptions.Description != nil {
		builder.AddFormData("description", "", "", fmt.Sprint(*updateDestinationOptions.Description))
	}
	if updateDestinationOptions.Config != nil {
		builder.AddFormData("config", "", "application/json", updateDestinationOptions.Config)
	}
	if updateDestinationOptions.Certificate != nil {
		builder.AddFormData("certificate", "",
			core.StringNilMapper(updateDestinationOptions.CertificateContentType), updateDestinationOptions.Certificate)
	}
	if updateDestinationOptions.Icon16x16 != nil {
		builder.AddFormData("icon_16x16", "",
			core.StringNilMapper(updateDestinationOptions.Icon16x16ContentType), updateDestinationOptions.Icon16x16)
	}
	if updateDestinationOptions.Icon16x162x != nil {
		builder.AddFormData("icon_16x16@2x", "",
			core.StringNilMapper(updateDestinationOptions.Icon16x162xContentType), updateDestinationOptions.Icon16x162x)
	}
	if updateDestinationOptions.Icon32x32 != nil {
		builder.AddFormData("icon_32x32", "",
			core.StringNilMapper(updateDestinationOptions.Icon32x32ContentType), updateDestinationOptions.Icon32x32)
	}
	if updateDestinationOptions.Icon32x322x != nil {
		builder.AddFormData("icon_32x32@2x", "",
			core.StringNilMapper(updateDestinationOptions.Icon32x322xContentType), updateDestinationOptions.Icon32x322x)
	}
	if updateDestinationOptions.Icon128x128 != nil {
		builder.AddFormData("icon_128x128", "",
			core.StringNilMapper(updateDestinationOptions.Icon128x128ContentType), updateDestinationOptions.Icon128x128)
	}
	if updateDestinationOptions.Icon128x1282x != nil {
		builder.AddFormData("icon_128x128@2x", "",
			core.StringNilMapper(updateDestinationOptions.Icon128x1282xContentType), updateDestinationOptions.Icon128x1282x)
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = eventNotifications.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalDestination)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// DeleteDestination : Delete a Destination
// Delete a Destination.
func (eventNotifications *EventNotificationsV1) DeleteDestination(deleteDestinationOptions *DeleteDestinationOptions) (response *core.DetailedResponse, err error) {
	return eventNotifications.DeleteDestinationWithContext(context.Background(), deleteDestinationOptions)
}

// DeleteDestinationWithContext is an alternate form of the DeleteDestination method which supports a Context parameter
func (eventNotifications *EventNotificationsV1) DeleteDestinationWithContext(ctx context.Context, deleteDestinationOptions *DeleteDestinationOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(deleteDestinationOptions, "deleteDestinationOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(deleteDestinationOptions, "deleteDestinationOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"instance_id": *deleteDestinationOptions.InstanceID,
		"id":          *deleteDestinationOptions.ID,
	}

	builder := core.NewRequestBuilder(core.DELETE)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = eventNotifications.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(eventNotifications.Service.Options.URL, `/v1/instances/{instance_id}/destinations/{id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range deleteDestinationOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("event_notifications", "V1", "DeleteDestination")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = eventNotifications.Service.Request(request, nil)

	return
}

// ListDestinationDevices : Get list of Destination devices
// Get list of Destination devices.
func (eventNotifications *EventNotificationsV1) ListDestinationDevices(listDestinationDevicesOptions *ListDestinationDevicesOptions) (result *DestinationDevicesList, response *core.DetailedResponse, err error) {
	return eventNotifications.ListDestinationDevicesWithContext(context.Background(), listDestinationDevicesOptions)
}

// ListDestinationDevicesWithContext is an alternate form of the ListDestinationDevices method which supports a Context parameter
func (eventNotifications *EventNotificationsV1) ListDestinationDevicesWithContext(ctx context.Context, listDestinationDevicesOptions *ListDestinationDevicesOptions) (result *DestinationDevicesList, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(listDestinationDevicesOptions, "listDestinationDevicesOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(listDestinationDevicesOptions, "listDestinationDevicesOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"instance_id": *listDestinationDevicesOptions.InstanceID,
		"id":          *listDestinationDevicesOptions.ID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = eventNotifications.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(eventNotifications.Service.Options.URL, `/v1/instances/{instance_id}/destinations/{id}/devices`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range listDestinationDevicesOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("event_notifications", "V1", "ListDestinationDevices")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	if listDestinationDevicesOptions.Limit != nil {
		builder.AddQuery("limit", fmt.Sprint(*listDestinationDevicesOptions.Limit))
	}
	if listDestinationDevicesOptions.Offset != nil {
		builder.AddQuery("offset", fmt.Sprint(*listDestinationDevicesOptions.Offset))
	}
	if listDestinationDevicesOptions.Search != nil {
		builder.AddQuery("search", fmt.Sprint(*listDestinationDevicesOptions.Search))
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = eventNotifications.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalDestinationDevicesList)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// GetDestinationDevicesReport : Retrieves report of destination devices registered
// Retrieves report of destination devices registered.
func (eventNotifications *EventNotificationsV1) GetDestinationDevicesReport(getDestinationDevicesReportOptions *GetDestinationDevicesReportOptions) (result *DestinationDevicesReport, response *core.DetailedResponse, err error) {
	return eventNotifications.GetDestinationDevicesReportWithContext(context.Background(), getDestinationDevicesReportOptions)
}

// GetDestinationDevicesReportWithContext is an alternate form of the GetDestinationDevicesReport method which supports a Context parameter
func (eventNotifications *EventNotificationsV1) GetDestinationDevicesReportWithContext(ctx context.Context, getDestinationDevicesReportOptions *GetDestinationDevicesReportOptions) (result *DestinationDevicesReport, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getDestinationDevicesReportOptions, "getDestinationDevicesReportOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getDestinationDevicesReportOptions, "getDestinationDevicesReportOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"instance_id": *getDestinationDevicesReportOptions.InstanceID,
		"id":          *getDestinationDevicesReportOptions.ID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = eventNotifications.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(eventNotifications.Service.Options.URL, `/v1/instances/{instance_id}/destinations/{id}/devices/report`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range getDestinationDevicesReportOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("event_notifications", "V1", "GetDestinationDevicesReport")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	if getDestinationDevicesReportOptions.Days != nil {
		builder.AddQuery("days", fmt.Sprint(*getDestinationDevicesReportOptions.Days))
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = eventNotifications.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalDestinationDevicesReport)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// ListTagsSubscriptionsDevice : List all Tag Subscriptions for a device
// List all Tag Subscriptions for a device.
func (eventNotifications *EventNotificationsV1) ListTagsSubscriptionsDevice(listTagsSubscriptionsDeviceOptions *ListTagsSubscriptionsDeviceOptions) (result *TagsSubscriptionList, response *core.DetailedResponse, err error) {
	return eventNotifications.ListTagsSubscriptionsDeviceWithContext(context.Background(), listTagsSubscriptionsDeviceOptions)
}

// ListTagsSubscriptionsDeviceWithContext is an alternate form of the ListTagsSubscriptionsDevice method which supports a Context parameter
func (eventNotifications *EventNotificationsV1) ListTagsSubscriptionsDeviceWithContext(ctx context.Context, listTagsSubscriptionsDeviceOptions *ListTagsSubscriptionsDeviceOptions) (result *TagsSubscriptionList, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(listTagsSubscriptionsDeviceOptions, "listTagsSubscriptionsDeviceOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(listTagsSubscriptionsDeviceOptions, "listTagsSubscriptionsDeviceOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"instance_id": *listTagsSubscriptionsDeviceOptions.InstanceID,
		"id":          *listTagsSubscriptionsDeviceOptions.ID,
		"device_id":   *listTagsSubscriptionsDeviceOptions.DeviceID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = eventNotifications.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(eventNotifications.Service.Options.URL, `/v1/instances/{instance_id}/destinations/{id}/tag_subscriptions/devices/{device_id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range listTagsSubscriptionsDeviceOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("event_notifications", "V1", "ListTagsSubscriptionsDevice")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	if listTagsSubscriptionsDeviceOptions.TagName != nil {
		builder.AddQuery("tag_name", fmt.Sprint(*listTagsSubscriptionsDeviceOptions.TagName))
	}
	if listTagsSubscriptionsDeviceOptions.Limit != nil {
		builder.AddQuery("limit", fmt.Sprint(*listTagsSubscriptionsDeviceOptions.Limit))
	}
	if listTagsSubscriptionsDeviceOptions.Offset != nil {
		builder.AddQuery("offset", fmt.Sprint(*listTagsSubscriptionsDeviceOptions.Offset))
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = eventNotifications.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalTagsSubscriptionList)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// ListTagsSubscription : List all Tag Subscriptions
// List all Tag Subscriptions.
func (eventNotifications *EventNotificationsV1) ListTagsSubscription(listTagsSubscriptionOptions *ListTagsSubscriptionOptions) (result *TagsSubscriptionList, response *core.DetailedResponse, err error) {
	return eventNotifications.ListTagsSubscriptionWithContext(context.Background(), listTagsSubscriptionOptions)
}

// ListTagsSubscriptionWithContext is an alternate form of the ListTagsSubscription method which supports a Context parameter
func (eventNotifications *EventNotificationsV1) ListTagsSubscriptionWithContext(ctx context.Context, listTagsSubscriptionOptions *ListTagsSubscriptionOptions) (result *TagsSubscriptionList, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(listTagsSubscriptionOptions, "listTagsSubscriptionOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(listTagsSubscriptionOptions, "listTagsSubscriptionOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"instance_id": *listTagsSubscriptionOptions.InstanceID,
		"id":          *listTagsSubscriptionOptions.ID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = eventNotifications.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(eventNotifications.Service.Options.URL, `/v1/instances/{instance_id}/destinations/{id}/tag_subscriptions`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range listTagsSubscriptionOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("event_notifications", "V1", "ListTagsSubscription")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	if listTagsSubscriptionOptions.DeviceID != nil {
		builder.AddQuery("device_id", fmt.Sprint(*listTagsSubscriptionOptions.DeviceID))
	}
	if listTagsSubscriptionOptions.UserID != nil {
		builder.AddQuery("user_id", fmt.Sprint(*listTagsSubscriptionOptions.UserID))
	}
	if listTagsSubscriptionOptions.TagName != nil {
		builder.AddQuery("tag_name", fmt.Sprint(*listTagsSubscriptionOptions.TagName))
	}
	if listTagsSubscriptionOptions.Limit != nil {
		builder.AddQuery("limit", fmt.Sprint(*listTagsSubscriptionOptions.Limit))
	}
	if listTagsSubscriptionOptions.Offset != nil {
		builder.AddQuery("offset", fmt.Sprint(*listTagsSubscriptionOptions.Offset))
	}
	if listTagsSubscriptionOptions.Search != nil {
		builder.AddQuery("search", fmt.Sprint(*listTagsSubscriptionOptions.Search))
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = eventNotifications.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalTagsSubscriptionList)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// CreateTagsSubscription : Create a new Tag subscription
// Create a new Tag subscription.
func (eventNotifications *EventNotificationsV1) CreateTagsSubscription(createTagsSubscriptionOptions *CreateTagsSubscriptionOptions) (result *DestinationTagsSubscriptionResponse, response *core.DetailedResponse, err error) {
	return eventNotifications.CreateTagsSubscriptionWithContext(context.Background(), createTagsSubscriptionOptions)
}

// CreateTagsSubscriptionWithContext is an alternate form of the CreateTagsSubscription method which supports a Context parameter
func (eventNotifications *EventNotificationsV1) CreateTagsSubscriptionWithContext(ctx context.Context, createTagsSubscriptionOptions *CreateTagsSubscriptionOptions) (result *DestinationTagsSubscriptionResponse, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(createTagsSubscriptionOptions, "createTagsSubscriptionOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(createTagsSubscriptionOptions, "createTagsSubscriptionOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"instance_id": *createTagsSubscriptionOptions.InstanceID,
		"id":          *createTagsSubscriptionOptions.ID,
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = eventNotifications.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(eventNotifications.Service.Options.URL, `/v1/instances/{instance_id}/destinations/{id}/tag_subscriptions`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range createTagsSubscriptionOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("event_notifications", "V1", "CreateTagsSubscription")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	body := make(map[string]interface{})
	if createTagsSubscriptionOptions.DeviceID != nil {
		body["device_id"] = createTagsSubscriptionOptions.DeviceID
	}
	if createTagsSubscriptionOptions.TagName != nil {
		body["tag_name"] = createTagsSubscriptionOptions.TagName
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = eventNotifications.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalDestinationTagsSubscriptionResponse)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// DeleteTagsSubscription : Delete a Tag subcription
// Delete a Tag subcription.
func (eventNotifications *EventNotificationsV1) DeleteTagsSubscription(deleteTagsSubscriptionOptions *DeleteTagsSubscriptionOptions) (response *core.DetailedResponse, err error) {
	return eventNotifications.DeleteTagsSubscriptionWithContext(context.Background(), deleteTagsSubscriptionOptions)
}

// DeleteTagsSubscriptionWithContext is an alternate form of the DeleteTagsSubscription method which supports a Context parameter
func (eventNotifications *EventNotificationsV1) DeleteTagsSubscriptionWithContext(ctx context.Context, deleteTagsSubscriptionOptions *DeleteTagsSubscriptionOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(deleteTagsSubscriptionOptions, "deleteTagsSubscriptionOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(deleteTagsSubscriptionOptions, "deleteTagsSubscriptionOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"instance_id": *deleteTagsSubscriptionOptions.InstanceID,
		"id":          *deleteTagsSubscriptionOptions.ID,
	}

	builder := core.NewRequestBuilder(core.DELETE)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = eventNotifications.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(eventNotifications.Service.Options.URL, `/v1/instances/{instance_id}/destinations/{id}/tag_subscriptions`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range deleteTagsSubscriptionOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("event_notifications", "V1", "DeleteTagsSubscription")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}

	if deleteTagsSubscriptionOptions.DeviceID != nil {
		builder.AddQuery("device_id", fmt.Sprint(*deleteTagsSubscriptionOptions.DeviceID))
	}
	if deleteTagsSubscriptionOptions.TagName != nil {
		builder.AddQuery("tag_name", fmt.Sprint(*deleteTagsSubscriptionOptions.TagName))
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = eventNotifications.Service.Request(request, nil)

	return
}

// CreateSubscription : Create a new Subscription
// Create a new Subscription.
func (eventNotifications *EventNotificationsV1) CreateSubscription(createSubscriptionOptions *CreateSubscriptionOptions) (result *Subscription, response *core.DetailedResponse, err error) {
	return eventNotifications.CreateSubscriptionWithContext(context.Background(), createSubscriptionOptions)
}

// CreateSubscriptionWithContext is an alternate form of the CreateSubscription method which supports a Context parameter
func (eventNotifications *EventNotificationsV1) CreateSubscriptionWithContext(ctx context.Context, createSubscriptionOptions *CreateSubscriptionOptions) (result *Subscription, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(createSubscriptionOptions, "createSubscriptionOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(createSubscriptionOptions, "createSubscriptionOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"instance_id": *createSubscriptionOptions.InstanceID,
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = eventNotifications.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(eventNotifications.Service.Options.URL, `/v1/instances/{instance_id}/subscriptions`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range createSubscriptionOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("event_notifications", "V1", "CreateSubscription")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	body := make(map[string]interface{})
	if createSubscriptionOptions.Name != nil {
		body["name"] = createSubscriptionOptions.Name
	}
	if createSubscriptionOptions.DestinationID != nil {
		body["destination_id"] = createSubscriptionOptions.DestinationID
	}
	if createSubscriptionOptions.TopicID != nil {
		body["topic_id"] = createSubscriptionOptions.TopicID
	}
	if createSubscriptionOptions.Description != nil {
		body["description"] = createSubscriptionOptions.Description
	}
	if createSubscriptionOptions.Attributes != nil {
		body["attributes"] = createSubscriptionOptions.Attributes
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = eventNotifications.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalSubscription)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// ListSubscriptions : List all Subscriptions
// List all Subscriptions.
func (eventNotifications *EventNotificationsV1) ListSubscriptions(listSubscriptionsOptions *ListSubscriptionsOptions) (result *SubscriptionList, response *core.DetailedResponse, err error) {
	return eventNotifications.ListSubscriptionsWithContext(context.Background(), listSubscriptionsOptions)
}

// ListSubscriptionsWithContext is an alternate form of the ListSubscriptions method which supports a Context parameter
func (eventNotifications *EventNotificationsV1) ListSubscriptionsWithContext(ctx context.Context, listSubscriptionsOptions *ListSubscriptionsOptions) (result *SubscriptionList, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(listSubscriptionsOptions, "listSubscriptionsOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(listSubscriptionsOptions, "listSubscriptionsOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"instance_id": *listSubscriptionsOptions.InstanceID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = eventNotifications.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(eventNotifications.Service.Options.URL, `/v1/instances/{instance_id}/subscriptions`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range listSubscriptionsOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("event_notifications", "V1", "ListSubscriptions")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	if listSubscriptionsOptions.Offset != nil {
		builder.AddQuery("offset", fmt.Sprint(*listSubscriptionsOptions.Offset))
	}
	if listSubscriptionsOptions.Limit != nil {
		builder.AddQuery("limit", fmt.Sprint(*listSubscriptionsOptions.Limit))
	}
	if listSubscriptionsOptions.Search != nil {
		builder.AddQuery("search", fmt.Sprint(*listSubscriptionsOptions.Search))
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = eventNotifications.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalSubscriptionList)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// GetSubscription : Get details of a Subscription
// Get details of a Subscription.
func (eventNotifications *EventNotificationsV1) GetSubscription(getSubscriptionOptions *GetSubscriptionOptions) (result *Subscription, response *core.DetailedResponse, err error) {
	return eventNotifications.GetSubscriptionWithContext(context.Background(), getSubscriptionOptions)
}

// GetSubscriptionWithContext is an alternate form of the GetSubscription method which supports a Context parameter
func (eventNotifications *EventNotificationsV1) GetSubscriptionWithContext(ctx context.Context, getSubscriptionOptions *GetSubscriptionOptions) (result *Subscription, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getSubscriptionOptions, "getSubscriptionOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getSubscriptionOptions, "getSubscriptionOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"instance_id": *getSubscriptionOptions.InstanceID,
		"id":          *getSubscriptionOptions.ID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = eventNotifications.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(eventNotifications.Service.Options.URL, `/v1/instances/{instance_id}/subscriptions/{id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range getSubscriptionOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("event_notifications", "V1", "GetSubscription")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = eventNotifications.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalSubscription)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// DeleteSubscription : Delete a Subscription
// Delete a Subscription.
func (eventNotifications *EventNotificationsV1) DeleteSubscription(deleteSubscriptionOptions *DeleteSubscriptionOptions) (response *core.DetailedResponse, err error) {
	return eventNotifications.DeleteSubscriptionWithContext(context.Background(), deleteSubscriptionOptions)
}

// DeleteSubscriptionWithContext is an alternate form of the DeleteSubscription method which supports a Context parameter
func (eventNotifications *EventNotificationsV1) DeleteSubscriptionWithContext(ctx context.Context, deleteSubscriptionOptions *DeleteSubscriptionOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(deleteSubscriptionOptions, "deleteSubscriptionOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(deleteSubscriptionOptions, "deleteSubscriptionOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"instance_id": *deleteSubscriptionOptions.InstanceID,
		"id":          *deleteSubscriptionOptions.ID,
	}

	builder := core.NewRequestBuilder(core.DELETE)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = eventNotifications.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(eventNotifications.Service.Options.URL, `/v1/instances/{instance_id}/subscriptions/{id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range deleteSubscriptionOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("event_notifications", "V1", "DeleteSubscription")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = eventNotifications.Service.Request(request, nil)

	return
}

// UpdateSubscription : Update details of a Subscription
// Update details of a Subscription.
func (eventNotifications *EventNotificationsV1) UpdateSubscription(updateSubscriptionOptions *UpdateSubscriptionOptions) (result *Subscription, response *core.DetailedResponse, err error) {
	return eventNotifications.UpdateSubscriptionWithContext(context.Background(), updateSubscriptionOptions)
}

// UpdateSubscriptionWithContext is an alternate form of the UpdateSubscription method which supports a Context parameter
func (eventNotifications *EventNotificationsV1) UpdateSubscriptionWithContext(ctx context.Context, updateSubscriptionOptions *UpdateSubscriptionOptions) (result *Subscription, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(updateSubscriptionOptions, "updateSubscriptionOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(updateSubscriptionOptions, "updateSubscriptionOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"instance_id": *updateSubscriptionOptions.InstanceID,
		"id":          *updateSubscriptionOptions.ID,
	}

	builder := core.NewRequestBuilder(core.PATCH)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = eventNotifications.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(eventNotifications.Service.Options.URL, `/v1/instances/{instance_id}/subscriptions/{id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range updateSubscriptionOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("event_notifications", "V1", "UpdateSubscription")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	body := make(map[string]interface{})
	if updateSubscriptionOptions.Name != nil {
		body["name"] = updateSubscriptionOptions.Name
	}
	if updateSubscriptionOptions.Description != nil {
		body["description"] = updateSubscriptionOptions.Description
	}
	if updateSubscriptionOptions.Attributes != nil {
		body["attributes"] = updateSubscriptionOptions.Attributes
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = eventNotifications.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalSubscription)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// BulkNotificationResponse : Payload describing a notifications response.
type BulkNotificationResponse struct {
	// Bulk Notification ID.
	BulkNotificationID *string `json:"bulk_notification_id,omitempty"`

	// List of Notifications.
	BulkMessages []interface{} `json:"bulk_messages,omitempty"`
}

// UnmarshalBulkNotificationResponse unmarshals an instance of BulkNotificationResponse from the specified map of raw messages.
func UnmarshalBulkNotificationResponse(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(BulkNotificationResponse)
	err = core.UnmarshalPrimitive(m, "bulk_notification_id", &obj.BulkNotificationID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "bulk_messages", &obj.BulkMessages)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// CreateDestinationOptions : The CreateDestination options.
type CreateDestinationOptions struct {
	// Unique identifier for IBM Cloud Event Notifications instance.
	InstanceID *string `json:"instance_id" validate:"required,ne="`

	// The Destintion name.
	Name *string `json:"name" validate:"required"`

	// The type of Destination Webhook.
	Type *string `json:"type" validate:"required"`

	// The Destination description.
	Description *string `json:"description,omitempty"`

	// Payload describing a destination configuration.
	Config *DestinationConfig `json:"config,omitempty"`

	// Certificate for APNS.
	Certificate io.ReadCloser `json:"certificate,omitempty"`

	// The content type of certificate.
	CertificateContentType *string `json:"certificate_content_type,omitempty"`

	// Safari icon 16x16.
	Icon16x16 io.ReadCloser `json:"icon_16x16,omitempty"`

	// The content type of icon16x16.
	Icon16x16ContentType *string `json:"icon_16x16_content_type,omitempty"`

	// Safari icon 16x16@2x.
	Icon16x162x io.ReadCloser `json:"icon_16x16@2x,omitempty"`

	// The content type of icon16x162x.
	Icon16x162xContentType *string `json:"icon_16x16@2x_content_type,omitempty"`

	// Safari icon 32x32.
	Icon32x32 io.ReadCloser `json:"icon_32x32,omitempty"`

	// The content type of icon32x32.
	Icon32x32ContentType *string `json:"icon_32x32_content_type,omitempty"`

	// Safari icon 32x32@2x.
	Icon32x322x io.ReadCloser `json:"icon_32x32@2x,omitempty"`

	// The content type of icon32x322x.
	Icon32x322xContentType *string `json:"icon_32x32@2x_content_type,omitempty"`

	// Safari icon 128x128.
	Icon128x128 io.ReadCloser `json:"icon_128x128,omitempty"`

	// The content type of icon128x128.
	Icon128x128ContentType *string `json:"icon_128x128_content_type,omitempty"`

	// Safari icon 128x128@2x.
	Icon128x1282x io.ReadCloser `json:"icon_128x128@2x,omitempty"`

	// The content type of icon128x1282x.
	Icon128x1282xContentType *string `json:"icon_128x128@2x_content_type,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// Constants associated with the CreateDestinationOptions.Type property.
// The type of Destination Webhook.
const (
	CreateDestinationOptionsTypePushAndroidConst = "push_android"
	CreateDestinationOptionsTypePushChromeConst  = "push_chrome"
	CreateDestinationOptionsTypePushFirefoxConst = "push_firefox"
	CreateDestinationOptionsTypePushIosConst     = "push_ios"
	CreateDestinationOptionsTypePushSafariConst  = "push_safari"
	CreateDestinationOptionsTypeSlackConst       = "slack"
	CreateDestinationOptionsTypeWebhookConst     = "webhook"
)

// NewCreateDestinationOptions : Instantiate CreateDestinationOptions
func (*EventNotificationsV1) NewCreateDestinationOptions(instanceID string, name string, typeVar string) *CreateDestinationOptions {
	return &CreateDestinationOptions{
		InstanceID: core.StringPtr(instanceID),
		Name:       core.StringPtr(name),
		Type:       core.StringPtr(typeVar),
	}
}

// SetInstanceID : Allow user to set InstanceID
func (_options *CreateDestinationOptions) SetInstanceID(instanceID string) *CreateDestinationOptions {
	_options.InstanceID = core.StringPtr(instanceID)
	return _options
}

// SetName : Allow user to set Name
func (_options *CreateDestinationOptions) SetName(name string) *CreateDestinationOptions {
	_options.Name = core.StringPtr(name)
	return _options
}

// SetType : Allow user to set Type
func (_options *CreateDestinationOptions) SetType(typeVar string) *CreateDestinationOptions {
	_options.Type = core.StringPtr(typeVar)
	return _options
}

// SetDescription : Allow user to set Description
func (_options *CreateDestinationOptions) SetDescription(description string) *CreateDestinationOptions {
	_options.Description = core.StringPtr(description)
	return _options
}

// SetConfig : Allow user to set Config
func (_options *CreateDestinationOptions) SetConfig(config *DestinationConfig) *CreateDestinationOptions {
	_options.Config = config
	return _options
}

// SetCertificate : Allow user to set Certificate
func (_options *CreateDestinationOptions) SetCertificate(certificate io.ReadCloser) *CreateDestinationOptions {
	_options.Certificate = certificate
	return _options
}

// SetCertificateContentType : Allow user to set CertificateContentType
func (_options *CreateDestinationOptions) SetCertificateContentType(certificateContentType string) *CreateDestinationOptions {
	_options.CertificateContentType = core.StringPtr(certificateContentType)
	return _options
}

// SetIcon16x16 : Allow user to set Icon16x16
func (_options *CreateDestinationOptions) SetIcon16x16(icon16x16 io.ReadCloser) *CreateDestinationOptions {
	_options.Icon16x16 = icon16x16
	return _options
}

// SetIcon16x16ContentType : Allow user to set Icon16x16ContentType
func (_options *CreateDestinationOptions) SetIcon16x16ContentType(icon16x16ContentType string) *CreateDestinationOptions {
	_options.Icon16x16ContentType = core.StringPtr(icon16x16ContentType)
	return _options
}

// SetIcon16x162x : Allow user to set Icon16x162x
func (_options *CreateDestinationOptions) SetIcon16x162x(icon16x162x io.ReadCloser) *CreateDestinationOptions {
	_options.Icon16x162x = icon16x162x
	return _options
}

// SetIcon16x162xContentType : Allow user to set Icon16x162xContentType
func (_options *CreateDestinationOptions) SetIcon16x162xContentType(icon16x162xContentType string) *CreateDestinationOptions {
	_options.Icon16x162xContentType = core.StringPtr(icon16x162xContentType)
	return _options
}

// SetIcon32x32 : Allow user to set Icon32x32
func (_options *CreateDestinationOptions) SetIcon32x32(icon32x32 io.ReadCloser) *CreateDestinationOptions {
	_options.Icon32x32 = icon32x32
	return _options
}

// SetIcon32x32ContentType : Allow user to set Icon32x32ContentType
func (_options *CreateDestinationOptions) SetIcon32x32ContentType(icon32x32ContentType string) *CreateDestinationOptions {
	_options.Icon32x32ContentType = core.StringPtr(icon32x32ContentType)
	return _options
}

// SetIcon32x322x : Allow user to set Icon32x322x
func (_options *CreateDestinationOptions) SetIcon32x322x(icon32x322x io.ReadCloser) *CreateDestinationOptions {
	_options.Icon32x322x = icon32x322x
	return _options
}

// SetIcon32x322xContentType : Allow user to set Icon32x322xContentType
func (_options *CreateDestinationOptions) SetIcon32x322xContentType(icon32x322xContentType string) *CreateDestinationOptions {
	_options.Icon32x322xContentType = core.StringPtr(icon32x322xContentType)
	return _options
}

// SetIcon128x128 : Allow user to set Icon128x128
func (_options *CreateDestinationOptions) SetIcon128x128(icon128x128 io.ReadCloser) *CreateDestinationOptions {
	_options.Icon128x128 = icon128x128
	return _options
}

// SetIcon128x128ContentType : Allow user to set Icon128x128ContentType
func (_options *CreateDestinationOptions) SetIcon128x128ContentType(icon128x128ContentType string) *CreateDestinationOptions {
	_options.Icon128x128ContentType = core.StringPtr(icon128x128ContentType)
	return _options
}

// SetIcon128x1282x : Allow user to set Icon128x1282x
func (_options *CreateDestinationOptions) SetIcon128x1282x(icon128x1282x io.ReadCloser) *CreateDestinationOptions {
	_options.Icon128x1282x = icon128x1282x
	return _options
}

// SetIcon128x1282xContentType : Allow user to set Icon128x1282xContentType
func (_options *CreateDestinationOptions) SetIcon128x1282xContentType(icon128x1282xContentType string) *CreateDestinationOptions {
	_options.Icon128x1282xContentType = core.StringPtr(icon128x1282xContentType)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *CreateDestinationOptions) SetHeaders(param map[string]string) *CreateDestinationOptions {
	options.Headers = param
	return options
}

// CreateSourcesOptions : The CreateSources options.
type CreateSourcesOptions struct {
	// Unique identifier for IBM Cloud Event Notifications instance.
	InstanceID *string `json:"instance_id" validate:"required,ne="`

	// Name of the source.
	Name *string `json:"name" validate:"required"`

	// Description of the source.
	Description *string `json:"description" validate:"required"`

	// Whether the source is enabled or not.
	Enabled *bool `json:"enabled,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewCreateSourcesOptions : Instantiate CreateSourcesOptions
func (*EventNotificationsV1) NewCreateSourcesOptions(instanceID string, name string, description string) *CreateSourcesOptions {
	return &CreateSourcesOptions{
		InstanceID:  core.StringPtr(instanceID),
		Name:        core.StringPtr(name),
		Description: core.StringPtr(description),
	}
}

// SetInstanceID : Allow user to set InstanceID
func (_options *CreateSourcesOptions) SetInstanceID(instanceID string) *CreateSourcesOptions {
	_options.InstanceID = core.StringPtr(instanceID)
	return _options
}

// SetName : Allow user to set Name
func (_options *CreateSourcesOptions) SetName(name string) *CreateSourcesOptions {
	_options.Name = core.StringPtr(name)
	return _options
}

// SetDescription : Allow user to set Description
func (_options *CreateSourcesOptions) SetDescription(description string) *CreateSourcesOptions {
	_options.Description = core.StringPtr(description)
	return _options
}

// SetEnabled : Allow user to set Enabled
func (_options *CreateSourcesOptions) SetEnabled(enabled bool) *CreateSourcesOptions {
	_options.Enabled = core.BoolPtr(enabled)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *CreateSourcesOptions) SetHeaders(param map[string]string) *CreateSourcesOptions {
	options.Headers = param
	return options
}

// CreateSubscriptionOptions : The CreateSubscription options.
type CreateSubscriptionOptions struct {
	// Unique identifier for IBM Cloud Event Notifications instance.
	InstanceID *string `json:"instance_id" validate:"required,ne="`

	// Subscription name.
	Name *string `json:"name" validate:"required"`

	// Destination ID.
	DestinationID *string `json:"destination_id" validate:"required"`

	// Topic ID.
	TopicID *string `json:"topic_id" validate:"required"`

	// Subscription description.
	Description *string `json:"description,omitempty"`

	Attributes SubscriptionCreateAttributesIntf `json:"attributes,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewCreateSubscriptionOptions : Instantiate CreateSubscriptionOptions
func (*EventNotificationsV1) NewCreateSubscriptionOptions(instanceID string, name string, destinationID string, topicID string) *CreateSubscriptionOptions {
	return &CreateSubscriptionOptions{
		InstanceID:    core.StringPtr(instanceID),
		Name:          core.StringPtr(name),
		DestinationID: core.StringPtr(destinationID),
		TopicID:       core.StringPtr(topicID),
	}
}

// SetInstanceID : Allow user to set InstanceID
func (_options *CreateSubscriptionOptions) SetInstanceID(instanceID string) *CreateSubscriptionOptions {
	_options.InstanceID = core.StringPtr(instanceID)
	return _options
}

// SetName : Allow user to set Name
func (_options *CreateSubscriptionOptions) SetName(name string) *CreateSubscriptionOptions {
	_options.Name = core.StringPtr(name)
	return _options
}

// SetDestinationID : Allow user to set DestinationID
func (_options *CreateSubscriptionOptions) SetDestinationID(destinationID string) *CreateSubscriptionOptions {
	_options.DestinationID = core.StringPtr(destinationID)
	return _options
}

// SetTopicID : Allow user to set TopicID
func (_options *CreateSubscriptionOptions) SetTopicID(topicID string) *CreateSubscriptionOptions {
	_options.TopicID = core.StringPtr(topicID)
	return _options
}

// SetDescription : Allow user to set Description
func (_options *CreateSubscriptionOptions) SetDescription(description string) *CreateSubscriptionOptions {
	_options.Description = core.StringPtr(description)
	return _options
}

// SetAttributes : Allow user to set Attributes
func (_options *CreateSubscriptionOptions) SetAttributes(attributes SubscriptionCreateAttributesIntf) *CreateSubscriptionOptions {
	_options.Attributes = attributes
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *CreateSubscriptionOptions) SetHeaders(param map[string]string) *CreateSubscriptionOptions {
	options.Headers = param
	return options
}

// CreateTagsSubscriptionOptions : The CreateTagsSubscription options.
type CreateTagsSubscriptionOptions struct {
	// Unique identifier for IBM Cloud Event Notifications instance.
	InstanceID *string `json:"instance_id" validate:"required,ne="`

	// Unique identifier for Destination.
	ID *string `json:"id" validate:"required,ne="`

	// Unique identifier of the device.
	DeviceID *string `json:"device_id" validate:"required"`

	// The name of the tag its subscribed.
	TagName *string `json:"tag_name" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewCreateTagsSubscriptionOptions : Instantiate CreateTagsSubscriptionOptions
func (*EventNotificationsV1) NewCreateTagsSubscriptionOptions(instanceID string, id string, deviceID string, tagName string) *CreateTagsSubscriptionOptions {
	return &CreateTagsSubscriptionOptions{
		InstanceID: core.StringPtr(instanceID),
		ID:         core.StringPtr(id),
		DeviceID:   core.StringPtr(deviceID),
		TagName:    core.StringPtr(tagName),
	}
}

// SetInstanceID : Allow user to set InstanceID
func (_options *CreateTagsSubscriptionOptions) SetInstanceID(instanceID string) *CreateTagsSubscriptionOptions {
	_options.InstanceID = core.StringPtr(instanceID)
	return _options
}

// SetID : Allow user to set ID
func (_options *CreateTagsSubscriptionOptions) SetID(id string) *CreateTagsSubscriptionOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetDeviceID : Allow user to set DeviceID
func (_options *CreateTagsSubscriptionOptions) SetDeviceID(deviceID string) *CreateTagsSubscriptionOptions {
	_options.DeviceID = core.StringPtr(deviceID)
	return _options
}

// SetTagName : Allow user to set TagName
func (_options *CreateTagsSubscriptionOptions) SetTagName(tagName string) *CreateTagsSubscriptionOptions {
	_options.TagName = core.StringPtr(tagName)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *CreateTagsSubscriptionOptions) SetHeaders(param map[string]string) *CreateTagsSubscriptionOptions {
	options.Headers = param
	return options
}

// CreateTopicOptions : The CreateTopic options.
type CreateTopicOptions struct {
	// Unique identifier for IBM Cloud Event Notifications instance.
	InstanceID *string `json:"instance_id" validate:"required,ne="`

	// Name of the topic.
	Name *string `json:"name" validate:"required"`

	// Description of the topic.
	Description *string `json:"description,omitempty"`

	// List of sources.
	Sources []TopicUpdateSourcesItem `json:"sources,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewCreateTopicOptions : Instantiate CreateTopicOptions
func (*EventNotificationsV1) NewCreateTopicOptions(instanceID string, name string) *CreateTopicOptions {
	return &CreateTopicOptions{
		InstanceID: core.StringPtr(instanceID),
		Name:       core.StringPtr(name),
	}
}

// SetInstanceID : Allow user to set InstanceID
func (_options *CreateTopicOptions) SetInstanceID(instanceID string) *CreateTopicOptions {
	_options.InstanceID = core.StringPtr(instanceID)
	return _options
}

// SetName : Allow user to set Name
func (_options *CreateTopicOptions) SetName(name string) *CreateTopicOptions {
	_options.Name = core.StringPtr(name)
	return _options
}

// SetDescription : Allow user to set Description
func (_options *CreateTopicOptions) SetDescription(description string) *CreateTopicOptions {
	_options.Description = core.StringPtr(description)
	return _options
}

// SetSources : Allow user to set Sources
func (_options *CreateTopicOptions) SetSources(sources []TopicUpdateSourcesItem) *CreateTopicOptions {
	_options.Sources = sources
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *CreateTopicOptions) SetHeaders(param map[string]string) *CreateTopicOptions {
	options.Headers = param
	return options
}

// DeleteDestinationOptions : The DeleteDestination options.
type DeleteDestinationOptions struct {
	// Unique identifier for IBM Cloud Event Notifications instance.
	InstanceID *string `json:"instance_id" validate:"required,ne="`

	// Unique identifier for Destination.
	ID *string `json:"id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewDeleteDestinationOptions : Instantiate DeleteDestinationOptions
func (*EventNotificationsV1) NewDeleteDestinationOptions(instanceID string, id string) *DeleteDestinationOptions {
	return &DeleteDestinationOptions{
		InstanceID: core.StringPtr(instanceID),
		ID:         core.StringPtr(id),
	}
}

// SetInstanceID : Allow user to set InstanceID
func (_options *DeleteDestinationOptions) SetInstanceID(instanceID string) *DeleteDestinationOptions {
	_options.InstanceID = core.StringPtr(instanceID)
	return _options
}

// SetID : Allow user to set ID
func (_options *DeleteDestinationOptions) SetID(id string) *DeleteDestinationOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *DeleteDestinationOptions) SetHeaders(param map[string]string) *DeleteDestinationOptions {
	options.Headers = param
	return options
}

// DeleteSourceOptions : The DeleteSource options.
type DeleteSourceOptions struct {
	// Unique identifier for IBM Cloud Event Notifications instance.
	InstanceID *string `json:"instance_id" validate:"required,ne="`

	// Unique identifier for Source.
	ID *string `json:"id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewDeleteSourceOptions : Instantiate DeleteSourceOptions
func (*EventNotificationsV1) NewDeleteSourceOptions(instanceID string, id string) *DeleteSourceOptions {
	return &DeleteSourceOptions{
		InstanceID: core.StringPtr(instanceID),
		ID:         core.StringPtr(id),
	}
}

// SetInstanceID : Allow user to set InstanceID
func (_options *DeleteSourceOptions) SetInstanceID(instanceID string) *DeleteSourceOptions {
	_options.InstanceID = core.StringPtr(instanceID)
	return _options
}

// SetID : Allow user to set ID
func (_options *DeleteSourceOptions) SetID(id string) *DeleteSourceOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *DeleteSourceOptions) SetHeaders(param map[string]string) *DeleteSourceOptions {
	options.Headers = param
	return options
}

// DeleteSubscriptionOptions : The DeleteSubscription options.
type DeleteSubscriptionOptions struct {
	// Unique identifier for IBM Cloud Event Notifications instance.
	InstanceID *string `json:"instance_id" validate:"required,ne="`

	// Unique identifier for Subscription.
	ID *string `json:"id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewDeleteSubscriptionOptions : Instantiate DeleteSubscriptionOptions
func (*EventNotificationsV1) NewDeleteSubscriptionOptions(instanceID string, id string) *DeleteSubscriptionOptions {
	return &DeleteSubscriptionOptions{
		InstanceID: core.StringPtr(instanceID),
		ID:         core.StringPtr(id),
	}
}

// SetInstanceID : Allow user to set InstanceID
func (_options *DeleteSubscriptionOptions) SetInstanceID(instanceID string) *DeleteSubscriptionOptions {
	_options.InstanceID = core.StringPtr(instanceID)
	return _options
}

// SetID : Allow user to set ID
func (_options *DeleteSubscriptionOptions) SetID(id string) *DeleteSubscriptionOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *DeleteSubscriptionOptions) SetHeaders(param map[string]string) *DeleteSubscriptionOptions {
	options.Headers = param
	return options
}

// DeleteTagsSubscriptionOptions : The DeleteTagsSubscription options.
type DeleteTagsSubscriptionOptions struct {
	// Unique identifier for IBM Cloud Event Notifications instance.
	InstanceID *string `json:"instance_id" validate:"required,ne="`

	// Unique identifier for Destination.
	ID *string `json:"id" validate:"required,ne="`

	// DeviceID of the destination tagsubscription.
	DeviceID *string `json:"device_id,omitempty"`

	// TagName of the subscription.
	TagName *string `json:"tag_name,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewDeleteTagsSubscriptionOptions : Instantiate DeleteTagsSubscriptionOptions
func (*EventNotificationsV1) NewDeleteTagsSubscriptionOptions(instanceID string, id string) *DeleteTagsSubscriptionOptions {
	return &DeleteTagsSubscriptionOptions{
		InstanceID: core.StringPtr(instanceID),
		ID:         core.StringPtr(id),
	}
}

// SetInstanceID : Allow user to set InstanceID
func (_options *DeleteTagsSubscriptionOptions) SetInstanceID(instanceID string) *DeleteTagsSubscriptionOptions {
	_options.InstanceID = core.StringPtr(instanceID)
	return _options
}

// SetID : Allow user to set ID
func (_options *DeleteTagsSubscriptionOptions) SetID(id string) *DeleteTagsSubscriptionOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetDeviceID : Allow user to set DeviceID
func (_options *DeleteTagsSubscriptionOptions) SetDeviceID(deviceID string) *DeleteTagsSubscriptionOptions {
	_options.DeviceID = core.StringPtr(deviceID)
	return _options
}

// SetTagName : Allow user to set TagName
func (_options *DeleteTagsSubscriptionOptions) SetTagName(tagName string) *DeleteTagsSubscriptionOptions {
	_options.TagName = core.StringPtr(tagName)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *DeleteTagsSubscriptionOptions) SetHeaders(param map[string]string) *DeleteTagsSubscriptionOptions {
	options.Headers = param
	return options
}

// DeleteTopicOptions : The DeleteTopic options.
type DeleteTopicOptions struct {
	// Unique identifier for IBM Cloud Event Notifications instance.
	InstanceID *string `json:"instance_id" validate:"required,ne="`

	// Unique identifier for Topic.
	ID *string `json:"id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewDeleteTopicOptions : Instantiate DeleteTopicOptions
func (*EventNotificationsV1) NewDeleteTopicOptions(instanceID string, id string) *DeleteTopicOptions {
	return &DeleteTopicOptions{
		InstanceID: core.StringPtr(instanceID),
		ID:         core.StringPtr(id),
	}
}

// SetInstanceID : Allow user to set InstanceID
func (_options *DeleteTopicOptions) SetInstanceID(instanceID string) *DeleteTopicOptions {
	_options.InstanceID = core.StringPtr(instanceID)
	return _options
}

// SetID : Allow user to set ID
func (_options *DeleteTopicOptions) SetID(id string) *DeleteTopicOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *DeleteTopicOptions) SetHeaders(param map[string]string) *DeleteTopicOptions {
	options.Headers = param
	return options
}

// Destination : Payload describing a destination get request.
type Destination struct {
	// Destination ID.
	ID *string `json:"id" validate:"required"`

	// Destination name.
	Name *string `json:"name" validate:"required"`

	// Destination description.
	Description *string `json:"description" validate:"required"`

	// Destination type Email/SMS/Webhook/FCM.
	Type *string `json:"type" validate:"required"`

	// Payload describing a destination configuration.
	Config *DestinationConfig `json:"config,omitempty"`

	// Last updated time.
	UpdatedAt *strfmt.DateTime `json:"updated_at" validate:"required"`

	// Number of subscriptions.
	SubscriptionCount *int64 `json:"subscription_count" validate:"required"`

	// List of subscriptions.
	SubscriptionNames []string `json:"subscription_names" validate:"required"`
}

// Constants associated with the Destination.Type property.
// Destination type Email/SMS/Webhook/FCM.
const (
	DestinationTypePushAndroidConst = "push_android"
	DestinationTypePushIosConst     = "push_ios"
	DestinationTypePushSafariConst  = "push_safari"
	DestinationTypeSMTPIBMConst     = "smtp_ibm"
	DestinationTypeSlackConst       = "slack"
	DestinationTypeSmsIBMConst      = "sms_ibm"
	DestinationTypeWebhookConst     = "webhook"
)

// UnmarshalDestination unmarshals an instance of Destination from the specified map of raw messages.
func UnmarshalDestination(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(Destination)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "description", &obj.Description)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "config", &obj.Config, UnmarshalDestinationConfig)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "updated_at", &obj.UpdatedAt)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "subscription_count", &obj.SubscriptionCount)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "subscription_names", &obj.SubscriptionNames)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// DestinationConfig : Payload describing a destination configuration.
type DestinationConfig struct {
	Params DestinationConfigParamsIntf `json:"params" validate:"required"`
}

// NewDestinationConfig : Instantiate DestinationConfig (Generic Model Constructor)
func (*EventNotificationsV1) NewDestinationConfig(params DestinationConfigParamsIntf) (_model *DestinationConfig, err error) {
	_model = &DestinationConfig{
		Params: params,
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

// UnmarshalDestinationConfig unmarshals an instance of DestinationConfig from the specified map of raw messages.
func UnmarshalDestinationConfig(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(DestinationConfig)
	err = core.UnmarshalModel(m, "params", &obj.Params, UnmarshalDestinationConfigParams)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// DestinationConfigParams : DestinationConfigParams struct
// Models which "extend" this model:
// - DestinationConfigParamsWebhookDestinationConfig
// - DestinationConfigParamsFcmDestinationConfig
// - DestinationConfigParamsIosDestinationConfig
// - DestinationConfigParamsChromeDestinationConfig
// - DestinationConfigParamsFirefoxDestinationConfig
// - DestinationConfigParamsSlackDestinationConfig
// - DestinationConfigParamsSafariDestinationConfig
type DestinationConfigParams struct {
	// URL of webhook.
	URL *string `json:"url,omitempty"`

	// HTTP method of webhook.
	Verb *string `json:"verb,omitempty"`

	// Custom headers (Key-Value pair) for webhook call.
	CustomHeaders map[string]string `json:"custom_headers,omitempty"`

	// List of sensitive headers from custom headers.
	SensitiveHeaders []string `json:"sensitive_headers,omitempty"`

	// FCM server_key.
	ServerKey *string `json:"server_key,omitempty"`

	// FCM sender_id.
	SenderID *string `json:"sender_id,omitempty"`

	// Authentication type (p8 or p12).
	CertType *string `json:"cert_type,omitempty"`

	// Sandbox mode for IOS destinations.
	IsSandbox *bool `json:"is_sandbox,omitempty"`

	// Password for certificate (Required when cert_type is p12).
	Password *string `json:"password,omitempty"`

	// Key ID for token (Required when cert_type is p8).
	KeyID *string `json:"key_id,omitempty"`

	// Team ID for token (Required when cert_type is p8).
	TeamID *string `json:"team_id,omitempty"`

	// Bundle ID for token (Required when cert_type is p8).
	BundleID *string `json:"bundle_id,omitempty"`

	// FCM api_key.
	APIKey *string `json:"api_key,omitempty"`

	// Website url.
	WebsiteURL *string `json:"website_url,omitempty"`

	// Chrome VAPID public key.
	PublicKey *string `json:"public_key,omitempty"`

	// Websire url.
	WebsiteName *string `json:"website_name,omitempty"`

	// Websire url.
	URLFormatString *string `json:"url_format_string,omitempty"`

	// Websire url.
	WebsitePushID *string `json:"website_push_id,omitempty"`
}

// Constants associated with the DestinationConfigParams.Verb property.
// HTTP method of webhook.
const (
	DestinationConfigParamsVerbGetConst  = "get"
	DestinationConfigParamsVerbPostConst = "post"
)

func (*DestinationConfigParams) isaDestinationConfigParams() bool {
	return true
}

type DestinationConfigParamsIntf interface {
	isaDestinationConfigParams() bool
}

// UnmarshalDestinationConfigParams unmarshals an instance of DestinationConfigParams from the specified map of raw messages.
func UnmarshalDestinationConfigParams(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(DestinationConfigParams)
	err = core.UnmarshalPrimitive(m, "url", &obj.URL)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "verb", &obj.Verb)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "custom_headers", &obj.CustomHeaders)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "sensitive_headers", &obj.SensitiveHeaders)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "server_key", &obj.ServerKey)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "sender_id", &obj.SenderID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "cert_type", &obj.CertType)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "is_sandbox", &obj.IsSandbox)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "password", &obj.Password)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "key_id", &obj.KeyID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "team_id", &obj.TeamID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "bundle_id", &obj.BundleID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "api_key", &obj.APIKey)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "website_url", &obj.WebsiteURL)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "public_key", &obj.PublicKey)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "website_name", &obj.WebsiteName)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "url_format_string", &obj.URLFormatString)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "website_push_id", &obj.WebsitePushID)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// DestinationDevicesList : Payload describing a destination devices list request.
type DestinationDevicesList struct {
	// Total number of destination devices.
	TotalCount *int64 `json:"total_count" validate:"required"`

	// Current offset.
	Offset *int64 `json:"offset" validate:"required"`

	// limit to show destination devices.
	Limit *int64 `json:"limit" validate:"required"`

	// List of devices.
	Devices []DestinationDevicesListItem `json:"devices" validate:"required"`
}

// UnmarshalDestinationDevicesList unmarshals an instance of DestinationDevicesList from the specified map of raw messages.
func UnmarshalDestinationDevicesList(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(DestinationDevicesList)
	err = core.UnmarshalPrimitive(m, "total_count", &obj.TotalCount)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "offset", &obj.Offset)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "limit", &obj.Limit)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "devices", &obj.Devices, UnmarshalDestinationDevicesListItem)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// DestinationDevicesListItem : device object.
type DestinationDevicesListItem struct {
	// device ID.
	ID *string `json:"id" validate:"required"`

	// user ID.
	UserID *string `json:"user_id,omitempty"`

	// Destination platform.
	Platform *string `json:"platform" validate:"required"`

	// Destination device token.
	Token *string `json:"token" validate:"required"`

	// Updated at.
	UpdatedAt *strfmt.DateTime `json:"updated_at" validate:"required"`
}

// UnmarshalDestinationDevicesListItem unmarshals an instance of DestinationDevicesListItem from the specified map of raw messages.
func UnmarshalDestinationDevicesListItem(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(DestinationDevicesListItem)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "user_id", &obj.UserID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "platform", &obj.Platform)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "token", &obj.Token)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "updated_at", &obj.UpdatedAt)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// DestinationDevicesReport : Payload describing a destination devices report.
type DestinationDevicesReport struct {
	// Android Devices Registered.
	Android *int64 `json:"android" validate:"required"`

	// ios Devices Registered.
	Ios *int64 `json:"ios" validate:"required"`

	// chrome web Devices Registered.
	Chrome *int64 `json:"chrome" validate:"required"`

	// firefox web Devices Registered.
	Firefox *int64 `json:"firefox" validate:"required"`

	// safari web Devices Registered.
	Safari *int64 `json:"safari" validate:"required"`

	// chromeAppExt Devices Registered.
	ChromeAppExt *int64 `json:"chromeAppExt" validate:"required"`

	// Total Devices Registered.
	All *int64 `json:"all" validate:"required"`
}

// UnmarshalDestinationDevicesReport unmarshals an instance of DestinationDevicesReport from the specified map of raw messages.
func UnmarshalDestinationDevicesReport(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(DestinationDevicesReport)
	err = core.UnmarshalPrimitive(m, "android", &obj.Android)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "ios", &obj.Ios)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "chrome", &obj.Chrome)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "firefox", &obj.Firefox)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "safari", &obj.Safari)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "chromeAppExt", &obj.ChromeAppExt)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "all", &obj.All)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// DestinationList : Payload describing a destination list request.
type DestinationList struct {
	// Total number of destinations.
	TotalCount *int64 `json:"total_count" validate:"required"`

	// Current offset.
	Offset *int64 `json:"offset" validate:"required"`

	// limit to show destinations.
	Limit *int64 `json:"limit" validate:"required"`

	// List of destinations.
	Destinations []DestinationListItem `json:"destinations" validate:"required"`
}

// UnmarshalDestinationList unmarshals an instance of DestinationList from the specified map of raw messages.
func UnmarshalDestinationList(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(DestinationList)
	err = core.UnmarshalPrimitive(m, "total_count", &obj.TotalCount)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "offset", &obj.Offset)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "limit", &obj.Limit)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "destinations", &obj.Destinations, UnmarshalDestinationListItem)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// DestinationListItem : Destination object.
type DestinationListItem struct {
	// Destination ID.
	ID *string `json:"id" validate:"required"`

	// Destination name.
	Name *string `json:"name" validate:"required"`

	// Destination description.
	Description *string `json:"description" validate:"required"`

	// Destination type.
	Type *string `json:"type" validate:"required"`

	// Subscription count.
	SubscriptionCount *int64 `json:"subscription_count" validate:"required"`

	// Names of subscriptions.
	SubscriptionNames []string `json:"subscription_names" validate:"required"`

	// Updated at.
	UpdatedAt *strfmt.DateTime `json:"updated_at" validate:"required"`
}

// Constants associated with the DestinationListItem.Type property.
// Destination type.
const (
	DestinationListItemTypePushAndroidConst = "push_android"
	DestinationListItemTypePushIosConst     = "push_ios"
	DestinationListItemTypePushSafariConst  = "push_safari"
	DestinationListItemTypeSMTPIBMConst     = "smtp_ibm"
	DestinationListItemTypeSlackConst       = "slack"
	DestinationListItemTypeSmsIBMConst      = "sms_ibm"
	DestinationListItemTypeWebhookConst     = "webhook"
)

// UnmarshalDestinationListItem unmarshals an instance of DestinationListItem from the specified map of raw messages.
func UnmarshalDestinationListItem(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(DestinationListItem)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "description", &obj.Description)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "subscription_count", &obj.SubscriptionCount)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "subscription_names", &obj.SubscriptionNames)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "updated_at", &obj.UpdatedAt)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// DestinationResponse : Payload describing a destination get request.
type DestinationResponse struct {
	// Destination ID.
	ID *string `json:"id" validate:"required"`

	// Destination name.
	Name *string `json:"name" validate:"required"`

	// Destination description.
	Description *string `json:"description" validate:"required"`

	// Destination type.
	Type *string `json:"type" validate:"required"`

	// Payload describing a destination configuration.
	Config *DestinationConfig `json:"config" validate:"required"`

	// Last updated time.
	CreatedAt *strfmt.DateTime `json:"created_at" validate:"required"`
}

// Constants associated with the DestinationResponse.Type property.
// Destination type.
const (
	DestinationResponseTypePushAndroidConst = "push_android"
	DestinationResponseTypePushChromeConst  = "push_chrome"
	DestinationResponseTypePushFirefoxConst = "push_firefox"
	DestinationResponseTypePushIosConst     = "push_ios"
	DestinationResponseTypePushSafariConst  = "push_safari"
	DestinationResponseTypeSlackConst       = "slack"
	DestinationResponseTypeWebhookConst     = "webhook"
)

// UnmarshalDestinationResponse unmarshals an instance of DestinationResponse from the specified map of raw messages.
func UnmarshalDestinationResponse(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(DestinationResponse)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "description", &obj.Description)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "config", &obj.Config, UnmarshalDestinationConfig)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "created_at", &obj.CreatedAt)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// DestinationTagsSubscriptionResponse : Payload describing a destination get request.
type DestinationTagsSubscriptionResponse struct {
	// Subscription Tag ID.
	ID *string `json:"id" validate:"required"`

	// Unique identifier of the device.
	DeviceID *string `json:"device_id" validate:"required"`

	// The name of the tag its subscribed.
	TagName *string `json:"tag_name" validate:"required"`

	// The user identifier for the the device registration.
	UserID *string `json:"user_id,omitempty"`

	// Last updated time.
	CreatedAt *strfmt.DateTime `json:"created_at" validate:"required"`
}

// UnmarshalDestinationTagsSubscriptionResponse unmarshals an instance of DestinationTagsSubscriptionResponse from the specified map of raw messages.
func UnmarshalDestinationTagsSubscriptionResponse(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(DestinationTagsSubscriptionResponse)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "device_id", &obj.DeviceID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "tag_name", &obj.TagName)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "user_id", &obj.UserID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "created_at", &obj.CreatedAt)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// EmailUpdateAttributesTo : The email ids.
type EmailUpdateAttributesTo struct {
	// The email ids.
	Add []string `json:"add,omitempty"`

	// The email ids for removal.
	Remove []string `json:"remove,omitempty"`
}

// UnmarshalEmailUpdateAttributesTo unmarshals an instance of EmailUpdateAttributesTo from the specified map of raw messages.
func UnmarshalEmailUpdateAttributesTo(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(EmailUpdateAttributesTo)
	err = core.UnmarshalPrimitive(m, "add", &obj.Add)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "remove", &obj.Remove)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// EmailUpdateAttributesUnsubscribed : The email ids.
type EmailUpdateAttributesUnsubscribed struct {
	// The email ids unsubscribed.
	Remove []string `json:"remove,omitempty"`
}

// UnmarshalEmailUpdateAttributesUnsubscribed unmarshals an instance of EmailUpdateAttributesUnsubscribed from the specified map of raw messages.
func UnmarshalEmailUpdateAttributesUnsubscribed(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(EmailUpdateAttributesUnsubscribed)
	err = core.UnmarshalPrimitive(m, "remove", &obj.Remove)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// GetDestinationDevicesReportOptions : The GetDestinationDevicesReport options.
type GetDestinationDevicesReportOptions struct {
	// Unique identifier for IBM Cloud Event Notifications instance.
	InstanceID *string `json:"instance_id" validate:"required,ne="`

	// Unique identifier for Destination.
	ID *string `json:"id" validate:"required,ne="`

	// Number of days report has to be generated from
	// * `Note :` Max value is 90
	// * Min or default value is 1.
	Days *int64 `json:"days,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetDestinationDevicesReportOptions : Instantiate GetDestinationDevicesReportOptions
func (*EventNotificationsV1) NewGetDestinationDevicesReportOptions(instanceID string, id string) *GetDestinationDevicesReportOptions {
	return &GetDestinationDevicesReportOptions{
		InstanceID: core.StringPtr(instanceID),
		ID:         core.StringPtr(id),
	}
}

// SetInstanceID : Allow user to set InstanceID
func (_options *GetDestinationDevicesReportOptions) SetInstanceID(instanceID string) *GetDestinationDevicesReportOptions {
	_options.InstanceID = core.StringPtr(instanceID)
	return _options
}

// SetID : Allow user to set ID
func (_options *GetDestinationDevicesReportOptions) SetID(id string) *GetDestinationDevicesReportOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetDays : Allow user to set Days
func (_options *GetDestinationDevicesReportOptions) SetDays(days int64) *GetDestinationDevicesReportOptions {
	_options.Days = core.Int64Ptr(days)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *GetDestinationDevicesReportOptions) SetHeaders(param map[string]string) *GetDestinationDevicesReportOptions {
	options.Headers = param
	return options
}

// GetDestinationOptions : The GetDestination options.
type GetDestinationOptions struct {
	// Unique identifier for IBM Cloud Event Notifications instance.
	InstanceID *string `json:"instance_id" validate:"required,ne="`

	// Unique identifier for Destination.
	ID *string `json:"id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetDestinationOptions : Instantiate GetDestinationOptions
func (*EventNotificationsV1) NewGetDestinationOptions(instanceID string, id string) *GetDestinationOptions {
	return &GetDestinationOptions{
		InstanceID: core.StringPtr(instanceID),
		ID:         core.StringPtr(id),
	}
}

// SetInstanceID : Allow user to set InstanceID
func (_options *GetDestinationOptions) SetInstanceID(instanceID string) *GetDestinationOptions {
	_options.InstanceID = core.StringPtr(instanceID)
	return _options
}

// SetID : Allow user to set ID
func (_options *GetDestinationOptions) SetID(id string) *GetDestinationOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *GetDestinationOptions) SetHeaders(param map[string]string) *GetDestinationOptions {
	options.Headers = param
	return options
}

// GetSourceOptions : The GetSource options.
type GetSourceOptions struct {
	// Unique identifier for IBM Cloud Event Notifications instance.
	InstanceID *string `json:"instance_id" validate:"required,ne="`

	// Unique identifier for Source.
	ID *string `json:"id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetSourceOptions : Instantiate GetSourceOptions
func (*EventNotificationsV1) NewGetSourceOptions(instanceID string, id string) *GetSourceOptions {
	return &GetSourceOptions{
		InstanceID: core.StringPtr(instanceID),
		ID:         core.StringPtr(id),
	}
}

// SetInstanceID : Allow user to set InstanceID
func (_options *GetSourceOptions) SetInstanceID(instanceID string) *GetSourceOptions {
	_options.InstanceID = core.StringPtr(instanceID)
	return _options
}

// SetID : Allow user to set ID
func (_options *GetSourceOptions) SetID(id string) *GetSourceOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *GetSourceOptions) SetHeaders(param map[string]string) *GetSourceOptions {
	options.Headers = param
	return options
}

// GetSubscriptionOptions : The GetSubscription options.
type GetSubscriptionOptions struct {
	// Unique identifier for IBM Cloud Event Notifications instance.
	InstanceID *string `json:"instance_id" validate:"required,ne="`

	// Unique identifier for Subscription.
	ID *string `json:"id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetSubscriptionOptions : Instantiate GetSubscriptionOptions
func (*EventNotificationsV1) NewGetSubscriptionOptions(instanceID string, id string) *GetSubscriptionOptions {
	return &GetSubscriptionOptions{
		InstanceID: core.StringPtr(instanceID),
		ID:         core.StringPtr(id),
	}
}

// SetInstanceID : Allow user to set InstanceID
func (_options *GetSubscriptionOptions) SetInstanceID(instanceID string) *GetSubscriptionOptions {
	_options.InstanceID = core.StringPtr(instanceID)
	return _options
}

// SetID : Allow user to set ID
func (_options *GetSubscriptionOptions) SetID(id string) *GetSubscriptionOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *GetSubscriptionOptions) SetHeaders(param map[string]string) *GetSubscriptionOptions {
	options.Headers = param
	return options
}

// GetTopicOptions : The GetTopic options.
type GetTopicOptions struct {
	// Unique identifier for IBM Cloud Event Notifications instance.
	InstanceID *string `json:"instance_id" validate:"required,ne="`

	// Unique identifier for Topic.
	ID *string `json:"id" validate:"required,ne="`

	// Include sub topics.
	Include *string `json:"include,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetTopicOptions : Instantiate GetTopicOptions
func (*EventNotificationsV1) NewGetTopicOptions(instanceID string, id string) *GetTopicOptions {
	return &GetTopicOptions{
		InstanceID: core.StringPtr(instanceID),
		ID:         core.StringPtr(id),
	}
}

// SetInstanceID : Allow user to set InstanceID
func (_options *GetTopicOptions) SetInstanceID(instanceID string) *GetTopicOptions {
	_options.InstanceID = core.StringPtr(instanceID)
	return _options
}

// SetID : Allow user to set ID
func (_options *GetTopicOptions) SetID(id string) *GetTopicOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetInclude : Allow user to set Include
func (_options *GetTopicOptions) SetInclude(include string) *GetTopicOptions {
	_options.Include = core.StringPtr(include)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *GetTopicOptions) SetHeaders(param map[string]string) *GetTopicOptions {
	options.Headers = param
	return options
}

// ListDestinationDevicesOptions : The ListDestinationDevices options.
type ListDestinationDevicesOptions struct {
	// Unique identifier for IBM Cloud Event Notifications instance.
	InstanceID *string `json:"instance_id" validate:"required,ne="`

	// Unique identifier for Destination.
	ID *string `json:"id" validate:"required,ne="`

	// Page limit for paginated results.
	Limit *int64 `json:"limit,omitempty"`

	// offset for paginated results.
	Offset *int64 `json:"offset,omitempty"`

	// Search string for filtering results.
	Search *string `json:"search,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewListDestinationDevicesOptions : Instantiate ListDestinationDevicesOptions
func (*EventNotificationsV1) NewListDestinationDevicesOptions(instanceID string, id string) *ListDestinationDevicesOptions {
	return &ListDestinationDevicesOptions{
		InstanceID: core.StringPtr(instanceID),
		ID:         core.StringPtr(id),
	}
}

// SetInstanceID : Allow user to set InstanceID
func (_options *ListDestinationDevicesOptions) SetInstanceID(instanceID string) *ListDestinationDevicesOptions {
	_options.InstanceID = core.StringPtr(instanceID)
	return _options
}

// SetID : Allow user to set ID
func (_options *ListDestinationDevicesOptions) SetID(id string) *ListDestinationDevicesOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetLimit : Allow user to set Limit
func (_options *ListDestinationDevicesOptions) SetLimit(limit int64) *ListDestinationDevicesOptions {
	_options.Limit = core.Int64Ptr(limit)
	return _options
}

// SetOffset : Allow user to set Offset
func (_options *ListDestinationDevicesOptions) SetOffset(offset int64) *ListDestinationDevicesOptions {
	_options.Offset = core.Int64Ptr(offset)
	return _options
}

// SetSearch : Allow user to set Search
func (_options *ListDestinationDevicesOptions) SetSearch(search string) *ListDestinationDevicesOptions {
	_options.Search = core.StringPtr(search)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *ListDestinationDevicesOptions) SetHeaders(param map[string]string) *ListDestinationDevicesOptions {
	options.Headers = param
	return options
}

// ListDestinationsOptions : The ListDestinations options.
type ListDestinationsOptions struct {
	// Unique identifier for IBM Cloud Event Notifications instance.
	InstanceID *string `json:"instance_id" validate:"required,ne="`

	// Page limit for paginated results.
	Limit *int64 `json:"limit,omitempty"`

	// offset for paginated results.
	Offset *int64 `json:"offset,omitempty"`

	// Search string for filtering results.
	Search *string `json:"search,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewListDestinationsOptions : Instantiate ListDestinationsOptions
func (*EventNotificationsV1) NewListDestinationsOptions(instanceID string) *ListDestinationsOptions {
	return &ListDestinationsOptions{
		InstanceID: core.StringPtr(instanceID),
	}
}

// SetInstanceID : Allow user to set InstanceID
func (_options *ListDestinationsOptions) SetInstanceID(instanceID string) *ListDestinationsOptions {
	_options.InstanceID = core.StringPtr(instanceID)
	return _options
}

// SetLimit : Allow user to set Limit
func (_options *ListDestinationsOptions) SetLimit(limit int64) *ListDestinationsOptions {
	_options.Limit = core.Int64Ptr(limit)
	return _options
}

// SetOffset : Allow user to set Offset
func (_options *ListDestinationsOptions) SetOffset(offset int64) *ListDestinationsOptions {
	_options.Offset = core.Int64Ptr(offset)
	return _options
}

// SetSearch : Allow user to set Search
func (_options *ListDestinationsOptions) SetSearch(search string) *ListDestinationsOptions {
	_options.Search = core.StringPtr(search)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *ListDestinationsOptions) SetHeaders(param map[string]string) *ListDestinationsOptions {
	options.Headers = param
	return options
}

// ListSourcesOptions : The ListSources options.
type ListSourcesOptions struct {
	// Unique identifier for IBM Cloud Event Notifications instance.
	InstanceID *string `json:"instance_id" validate:"required,ne="`

	// Page limit for paginated results.
	Limit *int64 `json:"limit,omitempty"`

	// offset for paginated results.
	Offset *int64 `json:"offset,omitempty"`

	// Search string for filtering results.
	Search *string `json:"search,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewListSourcesOptions : Instantiate ListSourcesOptions
func (*EventNotificationsV1) NewListSourcesOptions(instanceID string) *ListSourcesOptions {
	return &ListSourcesOptions{
		InstanceID: core.StringPtr(instanceID),
	}
}

// SetInstanceID : Allow user to set InstanceID
func (_options *ListSourcesOptions) SetInstanceID(instanceID string) *ListSourcesOptions {
	_options.InstanceID = core.StringPtr(instanceID)
	return _options
}

// SetLimit : Allow user to set Limit
func (_options *ListSourcesOptions) SetLimit(limit int64) *ListSourcesOptions {
	_options.Limit = core.Int64Ptr(limit)
	return _options
}

// SetOffset : Allow user to set Offset
func (_options *ListSourcesOptions) SetOffset(offset int64) *ListSourcesOptions {
	_options.Offset = core.Int64Ptr(offset)
	return _options
}

// SetSearch : Allow user to set Search
func (_options *ListSourcesOptions) SetSearch(search string) *ListSourcesOptions {
	_options.Search = core.StringPtr(search)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *ListSourcesOptions) SetHeaders(param map[string]string) *ListSourcesOptions {
	options.Headers = param
	return options
}

// ListSubscriptionsOptions : The ListSubscriptions options.
type ListSubscriptionsOptions struct {
	// Unique identifier for IBM Cloud Event Notifications instance.
	InstanceID *string `json:"instance_id" validate:"required,ne="`

	// offset for paginated results.
	Offset *int64 `json:"offset,omitempty"`

	// Page limit for paginated results.
	Limit *int64 `json:"limit,omitempty"`

	// Search string for filtering results.
	Search *string `json:"search,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewListSubscriptionsOptions : Instantiate ListSubscriptionsOptions
func (*EventNotificationsV1) NewListSubscriptionsOptions(instanceID string) *ListSubscriptionsOptions {
	return &ListSubscriptionsOptions{
		InstanceID: core.StringPtr(instanceID),
	}
}

// SetInstanceID : Allow user to set InstanceID
func (_options *ListSubscriptionsOptions) SetInstanceID(instanceID string) *ListSubscriptionsOptions {
	_options.InstanceID = core.StringPtr(instanceID)
	return _options
}

// SetOffset : Allow user to set Offset
func (_options *ListSubscriptionsOptions) SetOffset(offset int64) *ListSubscriptionsOptions {
	_options.Offset = core.Int64Ptr(offset)
	return _options
}

// SetLimit : Allow user to set Limit
func (_options *ListSubscriptionsOptions) SetLimit(limit int64) *ListSubscriptionsOptions {
	_options.Limit = core.Int64Ptr(limit)
	return _options
}

// SetSearch : Allow user to set Search
func (_options *ListSubscriptionsOptions) SetSearch(search string) *ListSubscriptionsOptions {
	_options.Search = core.StringPtr(search)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *ListSubscriptionsOptions) SetHeaders(param map[string]string) *ListSubscriptionsOptions {
	options.Headers = param
	return options
}

// ListTagsSubscriptionOptions : The ListTagsSubscription options.
type ListTagsSubscriptionOptions struct {
	// Unique identifier for IBM Cloud Event Notifications instance.
	InstanceID *string `json:"instance_id" validate:"required,ne="`

	// Unique identifier for Destination.
	ID *string `json:"id" validate:"required,ne="`

	// DeviceID of the destination tagsubscription.
	DeviceID *string `json:"device_id,omitempty"`

	// UserID of the destination.
	UserID *string `json:"user_id,omitempty"`

	// TagName of the subscription.
	TagName *string `json:"tag_name,omitempty"`

	// Page limit for paginated results.
	Limit *int64 `json:"limit,omitempty"`

	// offset for paginated results.
	Offset *int64 `json:"offset,omitempty"`

	// Search string for filtering results.
	Search *string `json:"search,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewListTagsSubscriptionOptions : Instantiate ListTagsSubscriptionOptions
func (*EventNotificationsV1) NewListTagsSubscriptionOptions(instanceID string, id string) *ListTagsSubscriptionOptions {
	return &ListTagsSubscriptionOptions{
		InstanceID: core.StringPtr(instanceID),
		ID:         core.StringPtr(id),
	}
}

// SetInstanceID : Allow user to set InstanceID
func (_options *ListTagsSubscriptionOptions) SetInstanceID(instanceID string) *ListTagsSubscriptionOptions {
	_options.InstanceID = core.StringPtr(instanceID)
	return _options
}

// SetID : Allow user to set ID
func (_options *ListTagsSubscriptionOptions) SetID(id string) *ListTagsSubscriptionOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetDeviceID : Allow user to set DeviceID
func (_options *ListTagsSubscriptionOptions) SetDeviceID(deviceID string) *ListTagsSubscriptionOptions {
	_options.DeviceID = core.StringPtr(deviceID)
	return _options
}

// SetUserID : Allow user to set UserID
func (_options *ListTagsSubscriptionOptions) SetUserID(userID string) *ListTagsSubscriptionOptions {
	_options.UserID = core.StringPtr(userID)
	return _options
}

// SetTagName : Allow user to set TagName
func (_options *ListTagsSubscriptionOptions) SetTagName(tagName string) *ListTagsSubscriptionOptions {
	_options.TagName = core.StringPtr(tagName)
	return _options
}

// SetLimit : Allow user to set Limit
func (_options *ListTagsSubscriptionOptions) SetLimit(limit int64) *ListTagsSubscriptionOptions {
	_options.Limit = core.Int64Ptr(limit)
	return _options
}

// SetOffset : Allow user to set Offset
func (_options *ListTagsSubscriptionOptions) SetOffset(offset int64) *ListTagsSubscriptionOptions {
	_options.Offset = core.Int64Ptr(offset)
	return _options
}

// SetSearch : Allow user to set Search
func (_options *ListTagsSubscriptionOptions) SetSearch(search string) *ListTagsSubscriptionOptions {
	_options.Search = core.StringPtr(search)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *ListTagsSubscriptionOptions) SetHeaders(param map[string]string) *ListTagsSubscriptionOptions {
	options.Headers = param
	return options
}

// ListTagsSubscriptionsDeviceOptions : The ListTagsSubscriptionsDevice options.
type ListTagsSubscriptionsDeviceOptions struct {
	// Unique identifier for IBM Cloud Event Notifications instance.
	InstanceID *string `json:"instance_id" validate:"required,ne="`

	// Unique identifier for Destination.
	ID *string `json:"id" validate:"required,ne="`

	// DeviceID of the destination.
	DeviceID *string `json:"device_id" validate:"required,ne="`

	// TagName of the subscription.
	TagName *string `json:"tag_name,omitempty"`

	// Page limit for paginated results.
	Limit *int64 `json:"limit,omitempty"`

	// offset for paginated results.
	Offset *int64 `json:"offset,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewListTagsSubscriptionsDeviceOptions : Instantiate ListTagsSubscriptionsDeviceOptions
func (*EventNotificationsV1) NewListTagsSubscriptionsDeviceOptions(instanceID string, id string, deviceID string) *ListTagsSubscriptionsDeviceOptions {
	return &ListTagsSubscriptionsDeviceOptions{
		InstanceID: core.StringPtr(instanceID),
		ID:         core.StringPtr(id),
		DeviceID:   core.StringPtr(deviceID),
	}
}

// SetInstanceID : Allow user to set InstanceID
func (_options *ListTagsSubscriptionsDeviceOptions) SetInstanceID(instanceID string) *ListTagsSubscriptionsDeviceOptions {
	_options.InstanceID = core.StringPtr(instanceID)
	return _options
}

// SetID : Allow user to set ID
func (_options *ListTagsSubscriptionsDeviceOptions) SetID(id string) *ListTagsSubscriptionsDeviceOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetDeviceID : Allow user to set DeviceID
func (_options *ListTagsSubscriptionsDeviceOptions) SetDeviceID(deviceID string) *ListTagsSubscriptionsDeviceOptions {
	_options.DeviceID = core.StringPtr(deviceID)
	return _options
}

// SetTagName : Allow user to set TagName
func (_options *ListTagsSubscriptionsDeviceOptions) SetTagName(tagName string) *ListTagsSubscriptionsDeviceOptions {
	_options.TagName = core.StringPtr(tagName)
	return _options
}

// SetLimit : Allow user to set Limit
func (_options *ListTagsSubscriptionsDeviceOptions) SetLimit(limit int64) *ListTagsSubscriptionsDeviceOptions {
	_options.Limit = core.Int64Ptr(limit)
	return _options
}

// SetOffset : Allow user to set Offset
func (_options *ListTagsSubscriptionsDeviceOptions) SetOffset(offset int64) *ListTagsSubscriptionsDeviceOptions {
	_options.Offset = core.Int64Ptr(offset)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *ListTagsSubscriptionsDeviceOptions) SetHeaders(param map[string]string) *ListTagsSubscriptionsDeviceOptions {
	options.Headers = param
	return options
}

// ListTopicsOptions : The ListTopics options.
type ListTopicsOptions struct {
	// Unique identifier for IBM Cloud Event Notifications instance.
	InstanceID *string `json:"instance_id" validate:"required,ne="`

	// Page limit for paginated results.
	Limit *int64 `json:"limit,omitempty"`

	// offset for paginated results.
	Offset *int64 `json:"offset,omitempty"`

	// Search string for filtering results.
	Search *string `json:"search,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewListTopicsOptions : Instantiate ListTopicsOptions
func (*EventNotificationsV1) NewListTopicsOptions(instanceID string) *ListTopicsOptions {
	return &ListTopicsOptions{
		InstanceID: core.StringPtr(instanceID),
	}
}

// SetInstanceID : Allow user to set InstanceID
func (_options *ListTopicsOptions) SetInstanceID(instanceID string) *ListTopicsOptions {
	_options.InstanceID = core.StringPtr(instanceID)
	return _options
}

// SetLimit : Allow user to set Limit
func (_options *ListTopicsOptions) SetLimit(limit int64) *ListTopicsOptions {
	_options.Limit = core.Int64Ptr(limit)
	return _options
}

// SetOffset : Allow user to set Offset
func (_options *ListTopicsOptions) SetOffset(offset int64) *ListTopicsOptions {
	_options.Offset = core.Int64Ptr(offset)
	return _options
}

// SetSearch : Allow user to set Search
func (_options *ListTopicsOptions) SetSearch(search string) *ListTopicsOptions {
	_options.Search = core.StringPtr(search)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *ListTopicsOptions) SetHeaders(param map[string]string) *ListTopicsOptions {
	options.Headers = param
	return options
}

// NotificationCreate : Payload describing a notification create request.
type NotificationCreate struct {
	// The Notifications data for webhook.
	Data map[string]interface{} `json:"data,omitempty"`

	// The Notifications id.
	Ibmenseverity *string `json:"ibmenseverity,omitempty"`

	// The Notifications FCM body.
	Ibmenfcmbody *string `json:"ibmenfcmbody,omitempty"`

	// The Notifications APNS body.
	Ibmenapnsbody *string `json:"ibmenapnsbody,omitempty"`

	// The Notifications safari body.
	Ibmensafaribody *string `json:"ibmensafaribody,omitempty"`

	// This field should not be empty. The allowed fields are fcm_devices, apns_devices, chrome_devices, firefox_devices,
	// platforms, tags and user_ids. If platforms or tags or user_ids are being used then do not use fcm_devices /
	// apns_devices / chrome_devices / firefox_devices with it.
	Ibmenpushto *string `json:"ibmenpushto,omitempty"`

	// Headers for an APNs notification.
	Ibmenapnsheaders *string `json:"ibmenapnsheaders,omitempty"`

	// Default short text for the message.
	Ibmendefaultshort *string `json:"ibmendefaultshort,omitempty"`

	// Default long text for the message.
	Ibmendefaultlong *string `json:"ibmendefaultlong,omitempty"`

	// The Notifications Chrome body.
	Ibmenchromebody *string `json:"ibmenchromebody,omitempty"`

	// The Notifications Firefox body.
	Ibmenfirefoxbody *string `json:"ibmenfirefoxbody,omitempty"`

	// Headers for a Chrome notification.
	Ibmenchromeheaders *string `json:"ibmenchromeheaders,omitempty"`

	// Headers for an FireFox notification.
	Ibmenfirefoxheaders *string `json:"ibmenfirefoxheaders,omitempty"`

	// The Event Notifications source id.
	Ibmensourceid *string `json:"ibmensourceid,omitempty"`

	// The Notifications content type.
	Datacontenttype *string `json:"datacontenttype,omitempty"`

	// The Notifications subject.
	Subject *string `json:"subject,omitempty"`

	// The Notifications id.
	ID *string `json:"id,omitempty"`

	// The source of Notifications.
	Source *string `json:"source,omitempty"`

	// The Notifications type.
	Type *string `json:"type,omitempty"`

	// The Notifications specversion.
	Specversion *string `json:"specversion,omitempty"`

	// The Notifications time.
	Time *string `json:"time,omitempty"`

	// Allows users to set arbitrary properties
	additionalProperties map[string]interface{}
}

// SetProperty allows the user to set an arbitrary property on an instance of NotificationCreate
func (o *NotificationCreate) SetProperty(key string, value interface{}) {
	if o.additionalProperties == nil {
		o.additionalProperties = make(map[string]interface{})
	}
	o.additionalProperties[key] = value
}

// SetProperties allows the user to set a map of arbitrary properties on an instance of NotificationCreate
func (o *NotificationCreate) SetProperties(m map[string]interface{}) {
	o.additionalProperties = make(map[string]interface{})
	for k, v := range m {
		o.additionalProperties[k] = v
	}
}

// GetProperty allows the user to retrieve an arbitrary property from an instance of NotificationCreate
func (o *NotificationCreate) GetProperty(key string) interface{} {
	return o.additionalProperties[key]
}

// GetProperties allows the user to retrieve the map of arbitrary properties from an instance of NotificationCreate
func (o *NotificationCreate) GetProperties() map[string]interface{} {
	return o.additionalProperties
}

// MarshalJSON performs custom serialization for instances of NotificationCreate
func (o *NotificationCreate) MarshalJSON() (buffer []byte, err error) {
	m := make(map[string]interface{})
	if len(o.additionalProperties) > 0 {
		for k, v := range o.additionalProperties {
			m[k] = v
		}
	}
	if o.Data != nil {
		m["data"] = o.Data
	}
	if o.Ibmenseverity != nil {
		m["ibmenseverity"] = o.Ibmenseverity
	}
	if o.Ibmenfcmbody != nil {
		m["ibmenfcmbody"] = o.Ibmenfcmbody
	}
	if o.Ibmenapnsbody != nil {
		m["ibmenapnsbody"] = o.Ibmenapnsbody
	}
	if o.Ibmensafaribody != nil {
		m["ibmensafaribody"] = o.Ibmensafaribody
	}
	if o.Ibmenpushto != nil {
		m["ibmenpushto"] = o.Ibmenpushto
	}
	if o.Ibmenapnsheaders != nil {
		m["ibmenapnsheaders"] = o.Ibmenapnsheaders
	}
	if o.Ibmendefaultshort != nil {
		m["ibmendefaultshort"] = o.Ibmendefaultshort
	}
	if o.Ibmendefaultlong != nil {
		m["ibmendefaultlong"] = o.Ibmendefaultlong
	}
	if o.Ibmenchromebody != nil {
		m["ibmenchromebody"] = o.Ibmenchromebody
	}
	if o.Ibmenfirefoxbody != nil {
		m["ibmenfirefoxbody"] = o.Ibmenfirefoxbody
	}
	if o.Ibmenchromeheaders != nil {
		m["ibmenchromeheaders"] = o.Ibmenchromeheaders
	}
	if o.Ibmenfirefoxheaders != nil {
		m["ibmenfirefoxheaders"] = o.Ibmenfirefoxheaders
	}
	if o.Ibmensourceid != nil {
		m["ibmensourceid"] = o.Ibmensourceid
	}
	if o.Datacontenttype != nil {
		m["datacontenttype"] = o.Datacontenttype
	}
	if o.Subject != nil {
		m["subject"] = o.Subject
	}
	if o.ID != nil {
		m["id"] = o.ID
	}
	if o.Source != nil {
		m["source"] = o.Source
	}
	if o.Type != nil {
		m["type"] = o.Type
	}
	if o.Specversion != nil {
		m["specversion"] = o.Specversion
	}
	if o.Time != nil {
		m["time"] = o.Time
	}
	buffer, err = json.Marshal(m)
	return
}

// UnmarshalNotificationCreate unmarshals an instance of NotificationCreate from the specified map of raw messages.
func UnmarshalNotificationCreate(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(NotificationCreate)
	err = core.UnmarshalPrimitive(m, "data", &obj.Data)
	if err != nil {
		return
	}
	delete(m, "data")
	err = core.UnmarshalPrimitive(m, "ibmenseverity", &obj.Ibmenseverity)
	if err != nil {
		return
	}
	delete(m, "ibmenseverity")
	err = core.UnmarshalPrimitive(m, "ibmenfcmbody", &obj.Ibmenfcmbody)
	if err != nil {
		return
	}
	delete(m, "ibmenfcmbody")
	err = core.UnmarshalPrimitive(m, "ibmenapnsbody", &obj.Ibmenapnsbody)
	if err != nil {
		return
	}
	delete(m, "ibmenapnsbody")
	err = core.UnmarshalPrimitive(m, "ibmensafaribody", &obj.Ibmensafaribody)
	if err != nil {
		return
	}
	delete(m, "ibmensafaribody")
	err = core.UnmarshalPrimitive(m, "ibmenpushto", &obj.Ibmenpushto)
	if err != nil {
		return
	}
	delete(m, "ibmenpushto")
	err = core.UnmarshalPrimitive(m, "ibmenapnsheaders", &obj.Ibmenapnsheaders)
	if err != nil {
		return
	}
	delete(m, "ibmenapnsheaders")
	err = core.UnmarshalPrimitive(m, "ibmendefaultshort", &obj.Ibmendefaultshort)
	if err != nil {
		return
	}
	delete(m, "ibmendefaultshort")
	err = core.UnmarshalPrimitive(m, "ibmendefaultlong", &obj.Ibmendefaultlong)
	if err != nil {
		return
	}
	delete(m, "ibmendefaultlong")
	err = core.UnmarshalPrimitive(m, "ibmenchromebody", &obj.Ibmenchromebody)
	if err != nil {
		return
	}
	delete(m, "ibmenchromebody")
	err = core.UnmarshalPrimitive(m, "ibmenfirefoxbody", &obj.Ibmenfirefoxbody)
	if err != nil {
		return
	}
	delete(m, "ibmenfirefoxbody")
	err = core.UnmarshalPrimitive(m, "ibmenchromeheaders", &obj.Ibmenchromeheaders)
	if err != nil {
		return
	}
	delete(m, "ibmenchromeheaders")
	err = core.UnmarshalPrimitive(m, "ibmenfirefoxheaders", &obj.Ibmenfirefoxheaders)
	if err != nil {
		return
	}
	delete(m, "ibmenfirefoxheaders")
	err = core.UnmarshalPrimitive(m, "ibmensourceid", &obj.Ibmensourceid)
	if err != nil {
		return
	}
	delete(m, "ibmensourceid")
	err = core.UnmarshalPrimitive(m, "datacontenttype", &obj.Datacontenttype)
	if err != nil {
		return
	}
	delete(m, "datacontenttype")
	err = core.UnmarshalPrimitive(m, "subject", &obj.Subject)
	if err != nil {
		return
	}
	delete(m, "subject")
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	delete(m, "id")
	err = core.UnmarshalPrimitive(m, "source", &obj.Source)
	if err != nil {
		return
	}
	delete(m, "source")
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	delete(m, "type")
	err = core.UnmarshalPrimitive(m, "specversion", &obj.Specversion)
	if err != nil {
		return
	}
	delete(m, "specversion")
	err = core.UnmarshalPrimitive(m, "time", &obj.Time)
	if err != nil {
		return
	}
	delete(m, "time")
	for k := range m {
		var v interface{}
		e := core.UnmarshalPrimitive(m, k, &v)
		if e != nil {
			err = e
			return
		}
		obj.SetProperty(k, v)
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// NotificationResponse : Payload describing a notifications response.
type NotificationResponse struct {
	// Notification ID.
	NotificationID *string `json:"notification_id,omitempty"`
}

// UnmarshalNotificationResponse unmarshals an instance of NotificationResponse from the specified map of raw messages.
func UnmarshalNotificationResponse(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(NotificationResponse)
	err = core.UnmarshalPrimitive(m, "notification_id", &obj.NotificationID)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ReplaceTopicOptions : The ReplaceTopic options.
type ReplaceTopicOptions struct {
	// Unique identifier for IBM Cloud Event Notifications instance.
	InstanceID *string `json:"instance_id" validate:"required,ne="`

	// Unique identifier for Topic.
	ID *string `json:"id" validate:"required,ne="`

	// Name of the topic.
	Name *string `json:"name,omitempty"`

	// Description of the topic.
	Description *string `json:"description,omitempty"`

	// List of sources.
	Sources []TopicUpdateSourcesItem `json:"sources,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewReplaceTopicOptions : Instantiate ReplaceTopicOptions
func (*EventNotificationsV1) NewReplaceTopicOptions(instanceID string, id string) *ReplaceTopicOptions {
	return &ReplaceTopicOptions{
		InstanceID: core.StringPtr(instanceID),
		ID:         core.StringPtr(id),
	}
}

// SetInstanceID : Allow user to set InstanceID
func (_options *ReplaceTopicOptions) SetInstanceID(instanceID string) *ReplaceTopicOptions {
	_options.InstanceID = core.StringPtr(instanceID)
	return _options
}

// SetID : Allow user to set ID
func (_options *ReplaceTopicOptions) SetID(id string) *ReplaceTopicOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetName : Allow user to set Name
func (_options *ReplaceTopicOptions) SetName(name string) *ReplaceTopicOptions {
	_options.Name = core.StringPtr(name)
	return _options
}

// SetDescription : Allow user to set Description
func (_options *ReplaceTopicOptions) SetDescription(description string) *ReplaceTopicOptions {
	_options.Description = core.StringPtr(description)
	return _options
}

// SetSources : Allow user to set Sources
func (_options *ReplaceTopicOptions) SetSources(sources []TopicUpdateSourcesItem) *ReplaceTopicOptions {
	_options.Sources = sources
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *ReplaceTopicOptions) SetHeaders(param map[string]string) *ReplaceTopicOptions {
	options.Headers = param
	return options
}

// Rules : Rule object.
type Rules struct {
	// Whether the rule is enabled or not.
	Enabled *bool `json:"enabled,omitempty"`

	// Event type filter.
	EventTypeFilter *string `json:"event_type_filter" validate:"required"`

	// Notification filter.
	NotificationFilter *string `json:"notification_filter,omitempty"`
}

// NewRules : Instantiate Rules (Generic Model Constructor)
func (*EventNotificationsV1) NewRules(eventTypeFilter string) (_model *Rules, err error) {
	_model = &Rules{
		EventTypeFilter: core.StringPtr(eventTypeFilter),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

// UnmarshalRules unmarshals an instance of Rules from the specified map of raw messages.
func UnmarshalRules(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(Rules)
	err = core.UnmarshalPrimitive(m, "enabled", &obj.Enabled)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "event_type_filter", &obj.EventTypeFilter)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "notification_filter", &obj.NotificationFilter)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// RulesGet : Rule object.
type RulesGet struct {
	// Whether the rule is enabled or not.
	Enabled *bool `json:"enabled" validate:"required"`

	// Event type filter.
	EventTypeFilter *string `json:"event_type_filter" validate:"required"`

	// Notification filter.
	NotificationFilter *string `json:"notification_filter" validate:"required"`

	// Last time the topic was updated.
	UpdatedAt *string `json:"updated_at" validate:"required"`

	// Autogenerated rule ID.
	ID *string `json:"id" validate:"required"`
}

// UnmarshalRulesGet unmarshals an instance of RulesGet from the specified map of raw messages.
func UnmarshalRulesGet(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(RulesGet)
	err = core.UnmarshalPrimitive(m, "enabled", &obj.Enabled)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "event_type_filter", &obj.EventTypeFilter)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "notification_filter", &obj.NotificationFilter)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "updated_at", &obj.UpdatedAt)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SendBulkNotificationsOptions : The SendBulkNotifications options.
type SendBulkNotificationsOptions struct {
	// Unique identifier for IBM Cloud Event Notifications instance.
	InstanceID *string `json:"instance_id" validate:"required,ne="`

	// List of notifications body.
	BulkMessages []NotificationCreate `json:"bulk_messages,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewSendBulkNotificationsOptions : Instantiate SendBulkNotificationsOptions
func (*EventNotificationsV1) NewSendBulkNotificationsOptions(instanceID string) *SendBulkNotificationsOptions {
	return &SendBulkNotificationsOptions{
		InstanceID: core.StringPtr(instanceID),
	}
}

// SetInstanceID : Allow user to set InstanceID
func (_options *SendBulkNotificationsOptions) SetInstanceID(instanceID string) *SendBulkNotificationsOptions {
	_options.InstanceID = core.StringPtr(instanceID)
	return _options
}

// SetBulkMessages : Allow user to set BulkMessages
func (_options *SendBulkNotificationsOptions) SetBulkMessages(bulkMessages []NotificationCreate) *SendBulkNotificationsOptions {
	_options.BulkMessages = bulkMessages
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *SendBulkNotificationsOptions) SetHeaders(param map[string]string) *SendBulkNotificationsOptions {
	options.Headers = param
	return options
}

// SendNotificationsOptions : The SendNotifications options.
type SendNotificationsOptions struct {
	// Unique identifier for IBM Cloud Event Notifications instance.
	InstanceID *string `json:"instance_id" validate:"required,ne="`

	// Payload describing a notification create request.
	Body *NotificationCreate `json:"body,omitempty"`

	// The Notification severity.
	CeIbmenseverity *string `json:"ce-ibmenseverity,omitempty"`

	// The Notification default short text.
	CeIbmendefaultshort *string `json:"ce-ibmendefaultshort,omitempty"`

	// The Notification default long text.
	CeIbmendefaultlong *string `json:"ce-ibmendefaultlong,omitempty"`

	// The FCM Notification body.
	CeIbmenfcmbody *string `json:"ce-ibmenfcmbody,omitempty"`

	// The APNS Notification body.
	CeIbmenapnsbody *string `json:"ce-ibmenapnsbody,omitempty"`

	// The safari Notification body.
	CeIbmensafaribody *string `json:"ce-ibmensafaribody,omitempty"`

	// Push Notifications Targets.
	CeIbmenpushto *string `json:"ce-ibmenpushto,omitempty"`

	// Push Notifications APNS Headers.
	CeIbmenapnsheaders *string `json:"ce-ibmenapnsheaders,omitempty"`

	// Push Notifications Chrome body.
	CeIbmenchromebody *string `json:"ce-ibmenchromebody,omitempty"`

	// Push Notifications Firefox body.
	CeIbmenfirefoxbody *string `json:"ce-ibmenfirefoxbody,omitempty"`

	// Push Notifications Chrome Headers.
	CeIbmenchromeheaders *string `json:"ce-ibmenchromeheaders,omitempty"`

	// Push Notifications Firefox Headers.
	CeIbmenfirefoxheaders *string `json:"ce-ibmenfirefoxheaders,omitempty"`

	// Event Notifications Target source ID.
	CeIbmensourceid *string `json:"ce-ibmensourceid,omitempty"`

	// custom ID to track notifications from client side (Mandatory identifier for the binary mode).
	CeID *string `json:"ce-id,omitempty"`

	// custom source odentifier from the client side.
	CeSource *string `json:"ce-source,omitempty"`

	// Type identifier for source filters.
	CeType *string `json:"ce-type,omitempty"`

	// Version of the Cloud Event specification (Mandatory header to make the request Binary Mode).
	CeSpecversion *string `json:"ce-specversion,omitempty"`

	// The time of the notification.
	CeTime *string `json:"ce-time,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewSendNotificationsOptions : Instantiate SendNotificationsOptions
func (*EventNotificationsV1) NewSendNotificationsOptions(instanceID string) *SendNotificationsOptions {
	return &SendNotificationsOptions{
		InstanceID: core.StringPtr(instanceID),
	}
}

// SetInstanceID : Allow user to set InstanceID
func (_options *SendNotificationsOptions) SetInstanceID(instanceID string) *SendNotificationsOptions {
	_options.InstanceID = core.StringPtr(instanceID)
	return _options
}

// SetBody : Allow user to set Body
func (_options *SendNotificationsOptions) SetBody(body *NotificationCreate) *SendNotificationsOptions {
	_options.Body = body
	return _options
}

// SetCeIbmenseverity : Allow user to set CeIbmenseverity
func (_options *SendNotificationsOptions) SetCeIbmenseverity(ceIbmenseverity string) *SendNotificationsOptions {
	_options.CeIbmenseverity = core.StringPtr(ceIbmenseverity)
	return _options
}

// SetCeIbmendefaultshort : Allow user to set CeIbmendefaultshort
func (_options *SendNotificationsOptions) SetCeIbmendefaultshort(ceIbmendefaultshort string) *SendNotificationsOptions {
	_options.CeIbmendefaultshort = core.StringPtr(ceIbmendefaultshort)
	return _options
}

// SetCeIbmendefaultlong : Allow user to set CeIbmendefaultlong
func (_options *SendNotificationsOptions) SetCeIbmendefaultlong(ceIbmendefaultlong string) *SendNotificationsOptions {
	_options.CeIbmendefaultlong = core.StringPtr(ceIbmendefaultlong)
	return _options
}

// SetCeIbmenfcmbody : Allow user to set CeIbmenfcmbody
func (_options *SendNotificationsOptions) SetCeIbmenfcmbody(ceIbmenfcmbody string) *SendNotificationsOptions {
	_options.CeIbmenfcmbody = core.StringPtr(ceIbmenfcmbody)
	return _options
}

// SetCeIbmenapnsbody : Allow user to set CeIbmenapnsbody
func (_options *SendNotificationsOptions) SetCeIbmenapnsbody(ceIbmenapnsbody string) *SendNotificationsOptions {
	_options.CeIbmenapnsbody = core.StringPtr(ceIbmenapnsbody)
	return _options
}

// SetCeIbmensafaribody : Allow user to set CeIbmensafaribody
func (_options *SendNotificationsOptions) SetCeIbmensafaribody(ceIbmensafaribody string) *SendNotificationsOptions {
	_options.CeIbmensafaribody = core.StringPtr(ceIbmensafaribody)
	return _options
}

// SetCeIbmenpushto : Allow user to set CeIbmenpushto
func (_options *SendNotificationsOptions) SetCeIbmenpushto(ceIbmenpushto string) *SendNotificationsOptions {
	_options.CeIbmenpushto = core.StringPtr(ceIbmenpushto)
	return _options
}

// SetCeIbmenapnsheaders : Allow user to set CeIbmenapnsheaders
func (_options *SendNotificationsOptions) SetCeIbmenapnsheaders(ceIbmenapnsheaders string) *SendNotificationsOptions {
	_options.CeIbmenapnsheaders = core.StringPtr(ceIbmenapnsheaders)
	return _options
}

// SetCeIbmenchromebody : Allow user to set CeIbmenchromebody
func (_options *SendNotificationsOptions) SetCeIbmenchromebody(ceIbmenchromebody string) *SendNotificationsOptions {
	_options.CeIbmenchromebody = core.StringPtr(ceIbmenchromebody)
	return _options
}

// SetCeIbmenfirefoxbody : Allow user to set CeIbmenfirefoxbody
func (_options *SendNotificationsOptions) SetCeIbmenfirefoxbody(ceIbmenfirefoxbody string) *SendNotificationsOptions {
	_options.CeIbmenfirefoxbody = core.StringPtr(ceIbmenfirefoxbody)
	return _options
}

// SetCeIbmenchromeheaders : Allow user to set CeIbmenchromeheaders
func (_options *SendNotificationsOptions) SetCeIbmenchromeheaders(ceIbmenchromeheaders string) *SendNotificationsOptions {
	_options.CeIbmenchromeheaders = core.StringPtr(ceIbmenchromeheaders)
	return _options
}

// SetCeIbmenfirefoxheaders : Allow user to set CeIbmenfirefoxheaders
func (_options *SendNotificationsOptions) SetCeIbmenfirefoxheaders(ceIbmenfirefoxheaders string) *SendNotificationsOptions {
	_options.CeIbmenfirefoxheaders = core.StringPtr(ceIbmenfirefoxheaders)
	return _options
}

// SetCeIbmensourceid : Allow user to set CeIbmensourceid
func (_options *SendNotificationsOptions) SetCeIbmensourceid(ceIbmensourceid string) *SendNotificationsOptions {
	_options.CeIbmensourceid = core.StringPtr(ceIbmensourceid)
	return _options
}

// SetCeID : Allow user to set CeID
func (_options *SendNotificationsOptions) SetCeID(ceID string) *SendNotificationsOptions {
	_options.CeID = core.StringPtr(ceID)
	return _options
}

// SetCeSource : Allow user to set CeSource
func (_options *SendNotificationsOptions) SetCeSource(ceSource string) *SendNotificationsOptions {
	_options.CeSource = core.StringPtr(ceSource)
	return _options
}

// SetCeType : Allow user to set CeType
func (_options *SendNotificationsOptions) SetCeType(ceType string) *SendNotificationsOptions {
	_options.CeType = core.StringPtr(ceType)
	return _options
}

// SetCeSpecversion : Allow user to set CeSpecversion
func (_options *SendNotificationsOptions) SetCeSpecversion(ceSpecversion string) *SendNotificationsOptions {
	_options.CeSpecversion = core.StringPtr(ceSpecversion)
	return _options
}

// SetCeTime : Allow user to set CeTime
func (_options *SendNotificationsOptions) SetCeTime(ceTime string) *SendNotificationsOptions {
	_options.CeTime = core.StringPtr(ceTime)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *SendNotificationsOptions) SetHeaders(param map[string]string) *SendNotificationsOptions {
	options.Headers = param
	return options
}

// Source : Payload describing a source generate request.
type Source struct {
	// The id of the source.
	ID *string `json:"id" validate:"required"`

	// The name of the source.
	Name *string `json:"name" validate:"required"`

	// The description of the source.
	Description *string `json:"description" validate:"required"`

	// The status of the source.
	Enabled *bool `json:"enabled" validate:"required"`

	// Type of the source.
	Type *string `json:"type" validate:"required"`

	// The last updated time of the source.
	UpdatedAt *strfmt.DateTime `json:"updated_at" validate:"required"`

	// The number of topics.
	TopicCount *int64 `json:"topic_count" validate:"required"`

	// The names of the topics.
	TopicNames []string `json:"topic_names" validate:"required"`
}

// UnmarshalSource unmarshals an instance of Source from the specified map of raw messages.
func UnmarshalSource(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(Source)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "description", &obj.Description)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "enabled", &obj.Enabled)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "updated_at", &obj.UpdatedAt)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "topic_count", &obj.TopicCount)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "topic_names", &obj.TopicNames)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SourceList : Payload describing a source list request.
type SourceList struct {
	// Number of sources.
	TotalCount *int64 `json:"total_count" validate:"required"`

	// Current offset.
	Offset *int64 `json:"offset" validate:"required"`

	// limit to show sources.
	Limit *int64 `json:"limit" validate:"required"`

	// List of sources.
	Sources []SourceListItem `json:"sources" validate:"required"`
}

// UnmarshalSourceList unmarshals an instance of SourceList from the specified map of raw messages.
func UnmarshalSourceList(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SourceList)
	err = core.UnmarshalPrimitive(m, "total_count", &obj.TotalCount)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "offset", &obj.Offset)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "limit", &obj.Limit)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "sources", &obj.Sources, UnmarshalSourceListItem)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SourceListItem : Payload describing a source list item.
type SourceListItem struct {
	// ID of the source.
	ID *string `json:"id" validate:"required"`

	// Name of the source.
	Name *string `json:"name" validate:"required"`

	// Description of the source.
	Description *string `json:"description" validate:"required"`

	// Type of the source.
	Type *string `json:"type" validate:"required"`

	// Whether the source is enabled or not.
	Enabled *bool `json:"enabled" validate:"required"`

	// Time of the last update.
	UpdatedAt *strfmt.DateTime `json:"updated_at" validate:"required"`

	// Number of topics.
	TopicCount *int64 `json:"topic_count" validate:"required"`
}

// UnmarshalSourceListItem unmarshals an instance of SourceListItem from the specified map of raw messages.
func UnmarshalSourceListItem(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SourceListItem)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "description", &obj.Description)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "enabled", &obj.Enabled)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "updated_at", &obj.UpdatedAt)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "topic_count", &obj.TopicCount)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SourceResponse : Payload describing a source.
type SourceResponse struct {
	// ID of the source.
	ID *string `json:"id" validate:"required"`

	// Name of the source.
	Name *string `json:"name" validate:"required"`

	// Description of the source.
	Description *string `json:"description" validate:"required"`

	// Whether the source is enabled or not.
	Enabled *bool `json:"enabled" validate:"required"`

	// Time of the created.
	CreatedAt *strfmt.DateTime `json:"created_at" validate:"required"`
}

// UnmarshalSourceResponse unmarshals an instance of SourceResponse from the specified map of raw messages.
func UnmarshalSourceResponse(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SourceResponse)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "description", &obj.Description)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "enabled", &obj.Enabled)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "created_at", &obj.CreatedAt)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SourcesListItem : SourcesListItem struct
type SourcesListItem struct {
	// ID of the source.
	ID *string `json:"id" validate:"required"`

	// Name of the source.
	Name *string `json:"name" validate:"required"`

	// List of rules.
	Rules []RulesGet `json:"rules" validate:"required"`
}

// UnmarshalSourcesListItem unmarshals an instance of SourcesListItem from the specified map of raw messages.
func UnmarshalSourcesListItem(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SourcesListItem)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "rules", &obj.Rules, UnmarshalRulesGet)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// Subscription : Subscription object.
type Subscription struct {
	// Subscription ID.
	ID *string `json:"id" validate:"required"`

	// Subscription name.
	Name *string `json:"name" validate:"required"`

	// Subscription description.
	Description *string `json:"description" validate:"required"`

	// Last updated time.
	UpdatedAt *string `json:"updated_at" validate:"required"`

	// From Email ID (it will be displayed only in case of smtp_ibm destination type).
	From *string `json:"from,omitempty"`

	// The type of destination.
	DestinationType *string `json:"destination_type" validate:"required"`

	// The destination ID.
	DestinationID *string `json:"destination_id" validate:"required"`

	// The destination name.
	DestinationName *string `json:"destination_name" validate:"required"`

	// Topic ID.
	TopicID *string `json:"topic_id" validate:"required"`

	// Topic name.
	TopicName *string `json:"topic_name" validate:"required"`

	Attributes SubscriptionAttributesIntf `json:"attributes,omitempty"`

	// Allows users to set arbitrary properties
	additionalProperties map[string]interface{}
}

// Constants associated with the Subscription.DestinationType property.
// The type of destination.
const (
	SubscriptionDestinationTypePushAndroidConst = "push_android"
	SubscriptionDestinationTypePushChromeConst  = "push_chrome"
	SubscriptionDestinationTypePushFirefoxConst = "push_firefox"
	SubscriptionDestinationTypePushIosConst     = "push_ios"
	SubscriptionDestinationTypePushSafariConst  = "push_safari"
	SubscriptionDestinationTypeSMTPIBMConst     = "smtp_ibm"
	SubscriptionDestinationTypeSlackConst       = "slack"
	SubscriptionDestinationTypeSmsIBMConst      = "sms_ibm"
	SubscriptionDestinationTypeWebhookConst     = "webhook"
)

// SetProperty allows the user to set an arbitrary property on an instance of Subscription
func (o *Subscription) SetProperty(key string, value interface{}) {
	if o.additionalProperties == nil {
		o.additionalProperties = make(map[string]interface{})
	}
	o.additionalProperties[key] = value
}

// SetProperties allows the user to set a map of arbitrary properties on an instance of Subscription
func (o *Subscription) SetProperties(m map[string]interface{}) {
	o.additionalProperties = make(map[string]interface{})
	for k, v := range m {
		o.additionalProperties[k] = v
	}
}

// GetProperty allows the user to retrieve an arbitrary property from an instance of Subscription
func (o *Subscription) GetProperty(key string) interface{} {
	return o.additionalProperties[key]
}

// GetProperties allows the user to retrieve the map of arbitrary properties from an instance of Subscription
func (o *Subscription) GetProperties() map[string]interface{} {
	return o.additionalProperties
}

// MarshalJSON performs custom serialization for instances of Subscription
func (o *Subscription) MarshalJSON() (buffer []byte, err error) {
	m := make(map[string]interface{})
	if len(o.additionalProperties) > 0 {
		for k, v := range o.additionalProperties {
			m[k] = v
		}
	}
	if o.ID != nil {
		m["id"] = o.ID
	}
	if o.Name != nil {
		m["name"] = o.Name
	}
	if o.Description != nil {
		m["description"] = o.Description
	}
	if o.UpdatedAt != nil {
		m["updated_at"] = o.UpdatedAt
	}
	if o.From != nil {
		m["from"] = o.From
	}
	if o.DestinationType != nil {
		m["destination_type"] = o.DestinationType
	}
	if o.DestinationID != nil {
		m["destination_id"] = o.DestinationID
	}
	if o.DestinationName != nil {
		m["destination_name"] = o.DestinationName
	}
	if o.TopicID != nil {
		m["topic_id"] = o.TopicID
	}
	if o.TopicName != nil {
		m["topic_name"] = o.TopicName
	}
	if o.Attributes != nil {
		m["attributes"] = o.Attributes
	}
	buffer, err = json.Marshal(m)
	return
}

// UnmarshalSubscription unmarshals an instance of Subscription from the specified map of raw messages.
func UnmarshalSubscription(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(Subscription)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	delete(m, "id")
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	delete(m, "name")
	err = core.UnmarshalPrimitive(m, "description", &obj.Description)
	if err != nil {
		return
	}
	delete(m, "description")
	err = core.UnmarshalPrimitive(m, "updated_at", &obj.UpdatedAt)
	if err != nil {
		return
	}
	delete(m, "updated_at")
	err = core.UnmarshalPrimitive(m, "from", &obj.From)
	if err != nil {
		return
	}
	delete(m, "from")
	err = core.UnmarshalPrimitive(m, "destination_type", &obj.DestinationType)
	if err != nil {
		return
	}
	delete(m, "destination_type")
	err = core.UnmarshalPrimitive(m, "destination_id", &obj.DestinationID)
	if err != nil {
		return
	}
	delete(m, "destination_id")
	err = core.UnmarshalPrimitive(m, "destination_name", &obj.DestinationName)
	if err != nil {
		return
	}
	delete(m, "destination_name")
	err = core.UnmarshalPrimitive(m, "topic_id", &obj.TopicID)
	if err != nil {
		return
	}
	delete(m, "topic_id")
	err = core.UnmarshalPrimitive(m, "topic_name", &obj.TopicName)
	if err != nil {
		return
	}
	delete(m, "topic_name")
	err = core.UnmarshalModel(m, "attributes", &obj.Attributes, UnmarshalSubscriptionAttributes)
	if err != nil {
		return
	}
	delete(m, "attributes")
	for k := range m {
		var v interface{}
		e := core.UnmarshalPrimitive(m, k, &v)
		if e != nil {
			err = e
			return
		}
		obj.SetProperty(k, v)
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SubscriptionAttributes : SubscriptionAttributes struct
// Models which "extend" this model:
// - SubscriptionAttributesSmsAttributesResponse
// - SubscriptionAttributesEmailAttributesResponse
// - SubscriptionAttributesWebhookAttributesResponse
// - SubscriptionAttributesSlackAttributesResponse
type SubscriptionAttributes struct {
	// Signing webhook attributes.
	SigningEnabled *bool `json:"signing_enabled,omitempty"`

	// Decision for Notification Payload to be added.
	AddNotificationPayload *bool `json:"add_notification_payload,omitempty"`

	// Attachment Color for Slack Notification.
	AttachmentColor *string `json:"attachment_color,omitempty"`

	// Allows users to set arbitrary properties
	additionalProperties map[string]interface{}
}

func (*SubscriptionAttributes) isaSubscriptionAttributes() bool {
	return true
}

type SubscriptionAttributesIntf interface {
	isaSubscriptionAttributes() bool
	SetProperty(key string, value interface{})
	SetProperties(m map[string]interface{})
	GetProperty(key string) interface{}
	GetProperties() map[string]interface{}
}

// SetProperty allows the user to set an arbitrary property on an instance of SubscriptionAttributes
func (o *SubscriptionAttributes) SetProperty(key string, value interface{}) {
	if o.additionalProperties == nil {
		o.additionalProperties = make(map[string]interface{})
	}
	o.additionalProperties[key] = value
}

// SetProperties allows the user to set a map of arbitrary properties on an instance of SubscriptionAttributes
func (o *SubscriptionAttributes) SetProperties(m map[string]interface{}) {
	o.additionalProperties = make(map[string]interface{})
	for k, v := range m {
		o.additionalProperties[k] = v
	}
}

// GetProperty allows the user to retrieve an arbitrary property from an instance of SubscriptionAttributes
func (o *SubscriptionAttributes) GetProperty(key string) interface{} {
	return o.additionalProperties[key]
}

// GetProperties allows the user to retrieve the map of arbitrary properties from an instance of SubscriptionAttributes
func (o *SubscriptionAttributes) GetProperties() map[string]interface{} {
	return o.additionalProperties
}

// MarshalJSON performs custom serialization for instances of SubscriptionAttributes
func (o *SubscriptionAttributes) MarshalJSON() (buffer []byte, err error) {
	m := make(map[string]interface{})
	if len(o.additionalProperties) > 0 {
		for k, v := range o.additionalProperties {
			m[k] = v
		}
	}
	if o.SigningEnabled != nil {
		m["signing_enabled"] = o.SigningEnabled
	}
	if o.AddNotificationPayload != nil {
		m["add_notification_payload"] = o.AddNotificationPayload
	}
	if o.AttachmentColor != nil {
		m["attachment_color"] = o.AttachmentColor
	}
	buffer, err = json.Marshal(m)
	return
}

// UnmarshalSubscriptionAttributes unmarshals an instance of SubscriptionAttributes from the specified map of raw messages.
func UnmarshalSubscriptionAttributes(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SubscriptionAttributes)
	err = core.UnmarshalPrimitive(m, "signing_enabled", &obj.SigningEnabled)
	if err != nil {
		return
	}
	delete(m, "signing_enabled")
	err = core.UnmarshalPrimitive(m, "add_notification_payload", &obj.AddNotificationPayload)
	if err != nil {
		return
	}
	delete(m, "add_notification_payload")
	err = core.UnmarshalPrimitive(m, "attachment_color", &obj.AttachmentColor)
	if err != nil {
		return
	}
	delete(m, "attachment_color")
	for k := range m {
		var v interface{}
		e := core.UnmarshalPrimitive(m, k, &v)
		if e != nil {
			err = e
			return
		}
		obj.SetProperty(k, v)
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SubscriptionCreateAttributes : SubscriptionCreateAttributes struct
// Models which "extend" this model:
// - SubscriptionCreateAttributesSmsAttributes
// - SubscriptionCreateAttributesEmailAttributes
// - SubscriptionCreateAttributesWebhookAttributes
// - SubscriptionCreateAttributesFcmAttributes
// - SubscriptionCreateAttributesSlackAttributes
type SubscriptionCreateAttributes struct {
	// The phone number to send the SMS to.
	To []string `json:"to,omitempty"`

	// Whether to add the notification payload to the email.
	AddNotificationPayload *bool `json:"add_notification_payload,omitempty"`

	// The email address to reply to.
	ReplyToMail *string `json:"reply_to_mail,omitempty"`

	// The email name to reply to.
	ReplyToName *string `json:"reply_to_name,omitempty"`

	// The email name of From.
	FromName *string `json:"from_name,omitempty"`

	// Signing webhook attributes.
	SigningEnabled *bool `json:"signing_enabled,omitempty"`

	// Attachment Color for the slack message.
	AttachmentColor *string `json:"attachment_color,omitempty"`
}

func (*SubscriptionCreateAttributes) isaSubscriptionCreateAttributes() bool {
	return true
}

type SubscriptionCreateAttributesIntf interface {
	isaSubscriptionCreateAttributes() bool
}

// UnmarshalSubscriptionCreateAttributes unmarshals an instance of SubscriptionCreateAttributes from the specified map of raw messages.
func UnmarshalSubscriptionCreateAttributes(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SubscriptionCreateAttributes)
	err = core.UnmarshalPrimitive(m, "to", &obj.To)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "add_notification_payload", &obj.AddNotificationPayload)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "reply_to_mail", &obj.ReplyToMail)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "reply_to_name", &obj.ReplyToName)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "from_name", &obj.FromName)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "signing_enabled", &obj.SigningEnabled)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "attachment_color", &obj.AttachmentColor)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SubscriptionList : Subscription list object.
type SubscriptionList struct {
	// Number of subscriptions.
	TotalCount *int64 `json:"total_count" validate:"required"`

	// Current offset.
	Offset *int64 `json:"offset" validate:"required"`

	// limit to show subscriptions.
	Limit *int64 `json:"limit" validate:"required"`

	// List of subscriptions.
	Subscriptions []SubscriptionListItem `json:"subscriptions" validate:"required"`
}

// UnmarshalSubscriptionList unmarshals an instance of SubscriptionList from the specified map of raw messages.
func UnmarshalSubscriptionList(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SubscriptionList)
	err = core.UnmarshalPrimitive(m, "total_count", &obj.TotalCount)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "offset", &obj.Offset)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "limit", &obj.Limit)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "subscriptions", &obj.Subscriptions, UnmarshalSubscriptionListItem)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SubscriptionListItem : Subscription list item.
type SubscriptionListItem struct {
	// ID of the subscription.
	ID *string `json:"id" validate:"required"`

	// Name of the subscription.
	Name *string `json:"name" validate:"required"`

	// Description of the subscription.
	Description *string `json:"description" validate:"required"`

	// ID of the destination.
	DestinationID *string `json:"destination_id" validate:"required"`

	// Name of the destination.
	DestinationName *string `json:"destination_name,omitempty"`

	// The type of destination.
	DestinationType *string `json:"destination_type" validate:"required"`

	// ID of the topic.
	TopicID *string `json:"topic_id" validate:"required"`

	// Name of the topic.
	TopicName *string `json:"topic_name,omitempty"`

	// Last updated time of the subscription.
	UpdatedAt *strfmt.DateTime `json:"updated_at" validate:"required"`
}

// Constants associated with the SubscriptionListItem.DestinationType property.
// The type of destination.
const (
	SubscriptionListItemDestinationTypePushAndroidConst = "push_android"
	SubscriptionListItemDestinationTypePushChromeConst  = "push_chrome"
	SubscriptionListItemDestinationTypePushFirefoxConst = "push_firefox"
	SubscriptionListItemDestinationTypePushIosConst     = "push_ios"
	SubscriptionListItemDestinationTypePushSafariConst  = "push_safari"
	SubscriptionListItemDestinationTypeSMTPIBMConst     = "smtp_ibm"
	SubscriptionListItemDestinationTypeSlackConst       = "slack"
	SubscriptionListItemDestinationTypeSmsIBMConst      = "sms_ibm"
	SubscriptionListItemDestinationTypeWebhookConst     = "webhook"
)

// UnmarshalSubscriptionListItem unmarshals an instance of SubscriptionListItem from the specified map of raw messages.
func UnmarshalSubscriptionListItem(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SubscriptionListItem)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "description", &obj.Description)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "destination_id", &obj.DestinationID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "destination_name", &obj.DestinationName)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "destination_type", &obj.DestinationType)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "topic_id", &obj.TopicID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "topic_name", &obj.TopicName)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "updated_at", &obj.UpdatedAt)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SubscriptionUpdateAttributes : SubscriptionUpdateAttributes struct
// Models which "extend" this model:
// - SubscriptionUpdateAttributesSmsAttributes
// - SubscriptionUpdateAttributesEmailUpdateAttributes
// - SubscriptionUpdateAttributesWebhookAttributes
// - SubscriptionUpdateAttributesSlackAttributes
type SubscriptionUpdateAttributes struct {
	// The phone number to send the SMS to.
	To []string `json:"to,omitempty"`

	// Whether to add the notification payload to the email.
	AddNotificationPayload *bool `json:"add_notification_payload,omitempty"`

	// The email address to reply to.
	ReplyToMail *string `json:"reply_to_mail,omitempty"`

	// The email name to reply to.
	ReplyToName *string `json:"reply_to_name,omitempty"`

	// The email name of From.
	FromName *string `json:"from_name,omitempty"`

	// The email ids invited.
	Invited []string `json:"invited,omitempty"`

	// The email ids.
	Unsubscribed *EmailUpdateAttributesUnsubscribed `json:"unsubscribed,omitempty"`

	// Signing webhook attributes.
	SigningEnabled *bool `json:"signing_enabled,omitempty"`

	// Attachment Color for the slack message.
	AttachmentColor *string `json:"attachment_color,omitempty"`
}

func (*SubscriptionUpdateAttributes) isaSubscriptionUpdateAttributes() bool {
	return true
}

type SubscriptionUpdateAttributesIntf interface {
	isaSubscriptionUpdateAttributes() bool
}

// UnmarshalSubscriptionUpdateAttributes unmarshals an instance of SubscriptionUpdateAttributes from the specified map of raw messages.
func UnmarshalSubscriptionUpdateAttributes(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SubscriptionUpdateAttributes)
	err = core.UnmarshalPrimitive(m, "to", &obj.To)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "add_notification_payload", &obj.AddNotificationPayload)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "reply_to_mail", &obj.ReplyToMail)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "reply_to_name", &obj.ReplyToName)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "from_name", &obj.FromName)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "invited", &obj.Invited)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "unsubscribed", &obj.Unsubscribed, UnmarshalEmailUpdateAttributesUnsubscribed)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "signing_enabled", &obj.SigningEnabled)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "attachment_color", &obj.AttachmentColor)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// TagsSubscriptionList : Payload describing a tags list request.
type TagsSubscriptionList struct {
	// Total number of tags.
	TotalCount *int64 `json:"total_count" validate:"required"`

	// Current offset.
	Offset *int64 `json:"offset" validate:"required"`

	// limit to show tags.
	Limit *int64 `json:"limit" validate:"required"`

	// List of tags.
	TagSubscriptions []TagsSubscriptionListItem `json:"tag_subscriptions" validate:"required"`
}

// UnmarshalTagsSubscriptionList unmarshals an instance of TagsSubscriptionList from the specified map of raw messages.
func UnmarshalTagsSubscriptionList(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(TagsSubscriptionList)
	err = core.UnmarshalPrimitive(m, "total_count", &obj.TotalCount)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "offset", &obj.Offset)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "limit", &obj.Limit)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "tag_subscriptions", &obj.TagSubscriptions, UnmarshalTagsSubscriptionListItem)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// TagsSubscriptionListItem : Tags subscription object.
type TagsSubscriptionListItem struct {
	// Subscription Tag ID.
	ID *string `json:"id" validate:"required"`

	// Unique identifier of the device.
	DeviceID *string `json:"device_id" validate:"required"`

	// The name of the tag its subscribed.
	TagName *string `json:"tag_name" validate:"required"`

	// The user identifier for the the device registration.
	UserID *string `json:"user_id,omitempty"`

	// Updated at.
	UpdatedAt *strfmt.DateTime `json:"updated_at" validate:"required"`
}

// UnmarshalTagsSubscriptionListItem unmarshals an instance of TagsSubscriptionListItem from the specified map of raw messages.
func UnmarshalTagsSubscriptionListItem(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(TagsSubscriptionListItem)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "device_id", &obj.DeviceID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "tag_name", &obj.TagName)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "user_id", &obj.UserID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "updated_at", &obj.UpdatedAt)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// Topic : Topic object.
type Topic struct {
	// Autogenerated topic ID.
	ID *string `json:"id" validate:"required"`

	// Description of the topic.
	Description *string `json:"description" validate:"required"`

	// Name of the topic.
	Name *string `json:"name" validate:"required"`

	// Last time the topic was updated.
	UpdatedAt *string `json:"updated_at" validate:"required"`

	// Number of sources.
	SourceCount *int64 `json:"source_count" validate:"required"`

	// List of sources.
	Sources []SourcesListItem `json:"sources" validate:"required"`

	// Number of subscriptions.
	SubscriptionCount *int64 `json:"subscription_count" validate:"required"`

	// List of subscriptions.
	Subscriptions []SubscriptionListItem `json:"subscriptions" validate:"required"`
}

// UnmarshalTopic unmarshals an instance of Topic from the specified map of raw messages.
func UnmarshalTopic(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(Topic)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "description", &obj.Description)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "updated_at", &obj.UpdatedAt)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "source_count", &obj.SourceCount)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "sources", &obj.Sources, UnmarshalSourcesListItem)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "subscription_count", &obj.SubscriptionCount)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "subscriptions", &obj.Subscriptions, UnmarshalSubscriptionListItem)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// TopicList : Topic list object.
type TopicList struct {
	// Number of topics.
	TotalCount *int64 `json:"total_count" validate:"required"`

	// Current offset.
	Offset *int64 `json:"offset" validate:"required"`

	// limit to show subscriptions.
	Limit *int64 `json:"limit" validate:"required"`

	// List of topics.
	Topics []TopicsListItem `json:"topics" validate:"required"`
}

// UnmarshalTopicList unmarshals an instance of TopicList from the specified map of raw messages.
func UnmarshalTopicList(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(TopicList)
	err = core.UnmarshalPrimitive(m, "total_count", &obj.TotalCount)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "offset", &obj.Offset)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "limit", &obj.Limit)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "topics", &obj.Topics, UnmarshalTopicsListItem)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// TopicResponse : Topic object.
type TopicResponse struct {
	// Autogenerated topic ID.
	ID *string `json:"id" validate:"required"`

	// Name of the topic.
	Name *string `json:"name" validate:"required"`

	// Description of the topic.
	Description *string `json:"description" validate:"required"`

	// Last time the topic was updated.
	CreatedAt *string `json:"created_at" validate:"required"`
}

// UnmarshalTopicResponse unmarshals an instance of TopicResponse from the specified map of raw messages.
func UnmarshalTopicResponse(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(TopicResponse)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "description", &obj.Description)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "created_at", &obj.CreatedAt)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// TopicUpdateSourcesItem : TopicUpdateSourcesItem struct
type TopicUpdateSourcesItem struct {
	// ID of the source.
	ID *string `json:"id" validate:"required"`

	// List of rules.
	Rules []Rules `json:"rules" validate:"required"`
}

// NewTopicUpdateSourcesItem : Instantiate TopicUpdateSourcesItem (Generic Model Constructor)
func (*EventNotificationsV1) NewTopicUpdateSourcesItem(id string, rules []Rules) (_model *TopicUpdateSourcesItem, err error) {
	_model = &TopicUpdateSourcesItem{
		ID:    core.StringPtr(id),
		Rules: rules,
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

// UnmarshalTopicUpdateSourcesItem unmarshals an instance of TopicUpdateSourcesItem from the specified map of raw messages.
func UnmarshalTopicUpdateSourcesItem(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(TopicUpdateSourcesItem)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "rules", &obj.Rules, UnmarshalRules)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// TopicsListItem : Topic list item object.
type TopicsListItem struct {
	// Autogenerated topic ID.
	ID *string `json:"id" validate:"required"`

	// Name of the topic.
	Name *string `json:"name" validate:"required"`

	// Description of the topic.
	Description *string `json:"description" validate:"required"`

	// Number of sources.
	SourceCount *int64 `json:"source_count" validate:"required"`

	// List of source names.
	SourcesNames []string `json:"sources_names" validate:"required"`

	// Number of subscriptions.
	SubscriptionCount *int64 `json:"subscription_count" validate:"required"`
}

// UnmarshalTopicsListItem unmarshals an instance of TopicsListItem from the specified map of raw messages.
func UnmarshalTopicsListItem(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(TopicsListItem)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "description", &obj.Description)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "source_count", &obj.SourceCount)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "sources_names", &obj.SourcesNames)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "subscription_count", &obj.SubscriptionCount)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// UpdateDestinationOptions : The UpdateDestination options.
type UpdateDestinationOptions struct {
	// Unique identifier for IBM Cloud Event Notifications instance.
	InstanceID *string `json:"instance_id" validate:"required,ne="`

	// Unique identifier for Destination.
	ID *string `json:"id" validate:"required,ne="`

	// Destination name.
	Name *string `json:"name,omitempty"`

	// Destination description.
	Description *string `json:"description,omitempty"`

	// Payload describing a destination configuration.
	Config *DestinationConfig `json:"config,omitempty"`

	// Certificate for APNS.
	Certificate io.ReadCloser `json:"certificate,omitempty"`

	// The content type of certificate.
	CertificateContentType *string `json:"certificate_content_type,omitempty"`

	// Safari icon 16x16.
	Icon16x16 io.ReadCloser `json:"icon_16x16,omitempty"`

	// The content type of icon16x16.
	Icon16x16ContentType *string `json:"icon_16x16_content_type,omitempty"`

	// Safari icon 16x16@2x.
	Icon16x162x io.ReadCloser `json:"icon_16x16@2x,omitempty"`

	// The content type of icon16x162x.
	Icon16x162xContentType *string `json:"icon_16x16@2x_content_type,omitempty"`

	// Safari icon 32x32.
	Icon32x32 io.ReadCloser `json:"icon_32x32,omitempty"`

	// The content type of icon32x32.
	Icon32x32ContentType *string `json:"icon_32x32_content_type,omitempty"`

	// Safari icon 32x32@2x.
	Icon32x322x io.ReadCloser `json:"icon_32x32@2x,omitempty"`

	// The content type of icon32x322x.
	Icon32x322xContentType *string `json:"icon_32x32@2x_content_type,omitempty"`

	// Safari icon 128x128.
	Icon128x128 io.ReadCloser `json:"icon_128x128,omitempty"`

	// The content type of icon128x128.
	Icon128x128ContentType *string `json:"icon_128x128_content_type,omitempty"`

	// Safari icon 128x128@2x.
	Icon128x1282x io.ReadCloser `json:"icon_128x128@2x,omitempty"`

	// The content type of icon128x1282x.
	Icon128x1282xContentType *string `json:"icon_128x128@2x_content_type,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewUpdateDestinationOptions : Instantiate UpdateDestinationOptions
func (*EventNotificationsV1) NewUpdateDestinationOptions(instanceID string, id string) *UpdateDestinationOptions {
	return &UpdateDestinationOptions{
		InstanceID: core.StringPtr(instanceID),
		ID:         core.StringPtr(id),
	}
}

// SetInstanceID : Allow user to set InstanceID
func (_options *UpdateDestinationOptions) SetInstanceID(instanceID string) *UpdateDestinationOptions {
	_options.InstanceID = core.StringPtr(instanceID)
	return _options
}

// SetID : Allow user to set ID
func (_options *UpdateDestinationOptions) SetID(id string) *UpdateDestinationOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetName : Allow user to set Name
func (_options *UpdateDestinationOptions) SetName(name string) *UpdateDestinationOptions {
	_options.Name = core.StringPtr(name)
	return _options
}

// SetDescription : Allow user to set Description
func (_options *UpdateDestinationOptions) SetDescription(description string) *UpdateDestinationOptions {
	_options.Description = core.StringPtr(description)
	return _options
}

// SetConfig : Allow user to set Config
func (_options *UpdateDestinationOptions) SetConfig(config *DestinationConfig) *UpdateDestinationOptions {
	_options.Config = config
	return _options
}

// SetCertificate : Allow user to set Certificate
func (_options *UpdateDestinationOptions) SetCertificate(certificate io.ReadCloser) *UpdateDestinationOptions {
	_options.Certificate = certificate
	return _options
}

// SetCertificateContentType : Allow user to set CertificateContentType
func (_options *UpdateDestinationOptions) SetCertificateContentType(certificateContentType string) *UpdateDestinationOptions {
	_options.CertificateContentType = core.StringPtr(certificateContentType)
	return _options
}

// SetIcon16x16 : Allow user to set Icon16x16
func (_options *UpdateDestinationOptions) SetIcon16x16(icon16x16 io.ReadCloser) *UpdateDestinationOptions {
	_options.Icon16x16 = icon16x16
	return _options
}

// SetIcon16x16ContentType : Allow user to set Icon16x16ContentType
func (_options *UpdateDestinationOptions) SetIcon16x16ContentType(icon16x16ContentType string) *UpdateDestinationOptions {
	_options.Icon16x16ContentType = core.StringPtr(icon16x16ContentType)
	return _options
}

// SetIcon16x162x : Allow user to set Icon16x162x
func (_options *UpdateDestinationOptions) SetIcon16x162x(icon16x162x io.ReadCloser) *UpdateDestinationOptions {
	_options.Icon16x162x = icon16x162x
	return _options
}

// SetIcon16x162xContentType : Allow user to set Icon16x162xContentType
func (_options *UpdateDestinationOptions) SetIcon16x162xContentType(icon16x162xContentType string) *UpdateDestinationOptions {
	_options.Icon16x162xContentType = core.StringPtr(icon16x162xContentType)
	return _options
}

// SetIcon32x32 : Allow user to set Icon32x32
func (_options *UpdateDestinationOptions) SetIcon32x32(icon32x32 io.ReadCloser) *UpdateDestinationOptions {
	_options.Icon32x32 = icon32x32
	return _options
}

// SetIcon32x32ContentType : Allow user to set Icon32x32ContentType
func (_options *UpdateDestinationOptions) SetIcon32x32ContentType(icon32x32ContentType string) *UpdateDestinationOptions {
	_options.Icon32x32ContentType = core.StringPtr(icon32x32ContentType)
	return _options
}

// SetIcon32x322x : Allow user to set Icon32x322x
func (_options *UpdateDestinationOptions) SetIcon32x322x(icon32x322x io.ReadCloser) *UpdateDestinationOptions {
	_options.Icon32x322x = icon32x322x
	return _options
}

// SetIcon32x322xContentType : Allow user to set Icon32x322xContentType
func (_options *UpdateDestinationOptions) SetIcon32x322xContentType(icon32x322xContentType string) *UpdateDestinationOptions {
	_options.Icon32x322xContentType = core.StringPtr(icon32x322xContentType)
	return _options
}

// SetIcon128x128 : Allow user to set Icon128x128
func (_options *UpdateDestinationOptions) SetIcon128x128(icon128x128 io.ReadCloser) *UpdateDestinationOptions {
	_options.Icon128x128 = icon128x128
	return _options
}

// SetIcon128x128ContentType : Allow user to set Icon128x128ContentType
func (_options *UpdateDestinationOptions) SetIcon128x128ContentType(icon128x128ContentType string) *UpdateDestinationOptions {
	_options.Icon128x128ContentType = core.StringPtr(icon128x128ContentType)
	return _options
}

// SetIcon128x1282x : Allow user to set Icon128x1282x
func (_options *UpdateDestinationOptions) SetIcon128x1282x(icon128x1282x io.ReadCloser) *UpdateDestinationOptions {
	_options.Icon128x1282x = icon128x1282x
	return _options
}

// SetIcon128x1282xContentType : Allow user to set Icon128x1282xContentType
func (_options *UpdateDestinationOptions) SetIcon128x1282xContentType(icon128x1282xContentType string) *UpdateDestinationOptions {
	_options.Icon128x1282xContentType = core.StringPtr(icon128x1282xContentType)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *UpdateDestinationOptions) SetHeaders(param map[string]string) *UpdateDestinationOptions {
	options.Headers = param
	return options
}

// UpdateSourceOptions : The UpdateSource options.
type UpdateSourceOptions struct {
	// Unique identifier for IBM Cloud Event Notifications instance.
	InstanceID *string `json:"instance_id" validate:"required,ne="`

	// Unique identifier for Source.
	ID *string `json:"id" validate:"required,ne="`

	// Name of the source.
	Name *string `json:"name,omitempty"`

	// Description of the source.
	Description *string `json:"description,omitempty"`

	// Whether the source is enabled or not.
	Enabled *bool `json:"enabled,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewUpdateSourceOptions : Instantiate UpdateSourceOptions
func (*EventNotificationsV1) NewUpdateSourceOptions(instanceID string, id string) *UpdateSourceOptions {
	return &UpdateSourceOptions{
		InstanceID: core.StringPtr(instanceID),
		ID:         core.StringPtr(id),
	}
}

// SetInstanceID : Allow user to set InstanceID
func (_options *UpdateSourceOptions) SetInstanceID(instanceID string) *UpdateSourceOptions {
	_options.InstanceID = core.StringPtr(instanceID)
	return _options
}

// SetID : Allow user to set ID
func (_options *UpdateSourceOptions) SetID(id string) *UpdateSourceOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetName : Allow user to set Name
func (_options *UpdateSourceOptions) SetName(name string) *UpdateSourceOptions {
	_options.Name = core.StringPtr(name)
	return _options
}

// SetDescription : Allow user to set Description
func (_options *UpdateSourceOptions) SetDescription(description string) *UpdateSourceOptions {
	_options.Description = core.StringPtr(description)
	return _options
}

// SetEnabled : Allow user to set Enabled
func (_options *UpdateSourceOptions) SetEnabled(enabled bool) *UpdateSourceOptions {
	_options.Enabled = core.BoolPtr(enabled)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *UpdateSourceOptions) SetHeaders(param map[string]string) *UpdateSourceOptions {
	options.Headers = param
	return options
}

// UpdateSubscriptionOptions : The UpdateSubscription options.
type UpdateSubscriptionOptions struct {
	// Unique identifier for IBM Cloud Event Notifications instance.
	InstanceID *string `json:"instance_id" validate:"required,ne="`

	// Unique identifier for Subscription.
	ID *string `json:"id" validate:"required,ne="`

	// Name of the subscription.
	Name *string `json:"name,omitempty"`

	// Description of the subscription.
	Description *string `json:"description,omitempty"`

	Attributes SubscriptionUpdateAttributesIntf `json:"attributes,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewUpdateSubscriptionOptions : Instantiate UpdateSubscriptionOptions
func (*EventNotificationsV1) NewUpdateSubscriptionOptions(instanceID string, id string) *UpdateSubscriptionOptions {
	return &UpdateSubscriptionOptions{
		InstanceID: core.StringPtr(instanceID),
		ID:         core.StringPtr(id),
	}
}

// SetInstanceID : Allow user to set InstanceID
func (_options *UpdateSubscriptionOptions) SetInstanceID(instanceID string) *UpdateSubscriptionOptions {
	_options.InstanceID = core.StringPtr(instanceID)
	return _options
}

// SetID : Allow user to set ID
func (_options *UpdateSubscriptionOptions) SetID(id string) *UpdateSubscriptionOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetName : Allow user to set Name
func (_options *UpdateSubscriptionOptions) SetName(name string) *UpdateSubscriptionOptions {
	_options.Name = core.StringPtr(name)
	return _options
}

// SetDescription : Allow user to set Description
func (_options *UpdateSubscriptionOptions) SetDescription(description string) *UpdateSubscriptionOptions {
	_options.Description = core.StringPtr(description)
	return _options
}

// SetAttributes : Allow user to set Attributes
func (_options *UpdateSubscriptionOptions) SetAttributes(attributes SubscriptionUpdateAttributesIntf) *UpdateSubscriptionOptions {
	_options.Attributes = attributes
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *UpdateSubscriptionOptions) SetHeaders(param map[string]string) *UpdateSubscriptionOptions {
	options.Headers = param
	return options
}

// DestinationConfigParamsChromeDestinationConfig : Payload describing a Chrome destination configuration.
// This model "extends" DestinationConfigParams
type DestinationConfigParamsChromeDestinationConfig struct {
	// FCM api_key.
	APIKey *string `json:"api_key" validate:"required"`

	// Website url.
	WebsiteURL *string `json:"website_url" validate:"required"`

	// Chrome VAPID public key.
	PublicKey *string `json:"public_key,omitempty"`
}

// NewDestinationConfigParamsChromeDestinationConfig : Instantiate DestinationConfigParamsChromeDestinationConfig (Generic Model Constructor)
func (*EventNotificationsV1) NewDestinationConfigParamsChromeDestinationConfig(apiKey string, websiteURL string) (_model *DestinationConfigParamsChromeDestinationConfig, err error) {
	_model = &DestinationConfigParamsChromeDestinationConfig{
		APIKey:     core.StringPtr(apiKey),
		WebsiteURL: core.StringPtr(websiteURL),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*DestinationConfigParamsChromeDestinationConfig) isaDestinationConfigParams() bool {
	return true
}

// UnmarshalDestinationConfigParamsChromeDestinationConfig unmarshals an instance of DestinationConfigParamsChromeDestinationConfig from the specified map of raw messages.
func UnmarshalDestinationConfigParamsChromeDestinationConfig(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(DestinationConfigParamsChromeDestinationConfig)
	err = core.UnmarshalPrimitive(m, "api_key", &obj.APIKey)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "website_url", &obj.WebsiteURL)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "public_key", &obj.PublicKey)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// DestinationConfigParamsFcmDestinationConfig : Payload describing a FCM destination configuration.
// This model "extends" DestinationConfigParams
type DestinationConfigParamsFcmDestinationConfig struct {
	// FCM server_key.
	ServerKey *string `json:"server_key" validate:"required"`

	// FCM sender_id.
	SenderID *string `json:"sender_id" validate:"required"`
}

// NewDestinationConfigParamsFcmDestinationConfig : Instantiate DestinationConfigParamsFcmDestinationConfig (Generic Model Constructor)
func (*EventNotificationsV1) NewDestinationConfigParamsFcmDestinationConfig(serverKey string, senderID string) (_model *DestinationConfigParamsFcmDestinationConfig, err error) {
	_model = &DestinationConfigParamsFcmDestinationConfig{
		ServerKey: core.StringPtr(serverKey),
		SenderID:  core.StringPtr(senderID),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*DestinationConfigParamsFcmDestinationConfig) isaDestinationConfigParams() bool {
	return true
}

// UnmarshalDestinationConfigParamsFcmDestinationConfig unmarshals an instance of DestinationConfigParamsFcmDestinationConfig from the specified map of raw messages.
func UnmarshalDestinationConfigParamsFcmDestinationConfig(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(DestinationConfigParamsFcmDestinationConfig)
	err = core.UnmarshalPrimitive(m, "server_key", &obj.ServerKey)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "sender_id", &obj.SenderID)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// DestinationConfigParamsFirefoxDestinationConfig : Payload describing a Firefox destination configuration.
// This model "extends" DestinationConfigParams
type DestinationConfigParamsFirefoxDestinationConfig struct {
	// Website url.
	WebsiteURL *string `json:"website_url" validate:"required"`

	// Chrome VAPID public key.
	PublicKey *string `json:"public_key,omitempty"`
}

// NewDestinationConfigParamsFirefoxDestinationConfig : Instantiate DestinationConfigParamsFirefoxDestinationConfig (Generic Model Constructor)
func (*EventNotificationsV1) NewDestinationConfigParamsFirefoxDestinationConfig(websiteURL string) (_model *DestinationConfigParamsFirefoxDestinationConfig, err error) {
	_model = &DestinationConfigParamsFirefoxDestinationConfig{
		WebsiteURL: core.StringPtr(websiteURL),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*DestinationConfigParamsFirefoxDestinationConfig) isaDestinationConfigParams() bool {
	return true
}

// UnmarshalDestinationConfigParamsFirefoxDestinationConfig unmarshals an instance of DestinationConfigParamsFirefoxDestinationConfig from the specified map of raw messages.
func UnmarshalDestinationConfigParamsFirefoxDestinationConfig(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(DestinationConfigParamsFirefoxDestinationConfig)
	err = core.UnmarshalPrimitive(m, "website_url", &obj.WebsiteURL)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "public_key", &obj.PublicKey)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// DestinationConfigParamsIosDestinationConfig : Payload describing a IOS destination configuration.
// This model "extends" DestinationConfigParams
type DestinationConfigParamsIosDestinationConfig struct {
	// Authentication type (p8 or p12).
	CertType *string `json:"cert_type" validate:"required"`

	// Sandbox mode for IOS destinations.
	IsSandbox *bool `json:"is_sandbox" validate:"required"`

	// Password for certificate (Required when cert_type is p12).
	Password *string `json:"password,omitempty"`

	// Key ID for token (Required when cert_type is p8).
	KeyID *string `json:"key_id,omitempty"`

	// Team ID for token (Required when cert_type is p8).
	TeamID *string `json:"team_id,omitempty"`

	// Bundle ID for token (Required when cert_type is p8).
	BundleID *string `json:"bundle_id,omitempty"`
}

// NewDestinationConfigParamsIosDestinationConfig : Instantiate DestinationConfigParamsIosDestinationConfig (Generic Model Constructor)
func (*EventNotificationsV1) NewDestinationConfigParamsIosDestinationConfig(certType string, isSandbox bool) (_model *DestinationConfigParamsIosDestinationConfig, err error) {
	_model = &DestinationConfigParamsIosDestinationConfig{
		CertType:  core.StringPtr(certType),
		IsSandbox: core.BoolPtr(isSandbox),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*DestinationConfigParamsIosDestinationConfig) isaDestinationConfigParams() bool {
	return true
}

// UnmarshalDestinationConfigParamsIosDestinationConfig unmarshals an instance of DestinationConfigParamsIosDestinationConfig from the specified map of raw messages.
func UnmarshalDestinationConfigParamsIosDestinationConfig(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(DestinationConfigParamsIosDestinationConfig)
	err = core.UnmarshalPrimitive(m, "cert_type", &obj.CertType)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "is_sandbox", &obj.IsSandbox)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "password", &obj.Password)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "key_id", &obj.KeyID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "team_id", &obj.TeamID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "bundle_id", &obj.BundleID)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// DestinationConfigParamsSafariDestinationConfig : Payload describing a safari destination configuration.
// This model "extends" DestinationConfigParams
type DestinationConfigParamsSafariDestinationConfig struct {
	// Authentication type p12.
	CertType *string `json:"cert_type,omitempty"`

	// Password for certificate (Required when cert_type is p12).
	Password *string `json:"password" validate:"required"`

	// Websire url.
	WebsiteURL *string `json:"website_url" validate:"required"`

	// Websire url.
	WebsiteName *string `json:"website_name" validate:"required"`

	// Websire url.
	URLFormatString *string `json:"url_format_string" validate:"required"`

	// Websire url.
	WebsitePushID *string `json:"website_push_id" validate:"required"`
}

// NewDestinationConfigParamsSafariDestinationConfig : Instantiate DestinationConfigParamsSafariDestinationConfig (Generic Model Constructor)
func (*EventNotificationsV1) NewDestinationConfigParamsSafariDestinationConfig(password string, websiteURL string, websiteName string, urlFormatString string, websitePushID string) (_model *DestinationConfigParamsSafariDestinationConfig, err error) {
	_model = &DestinationConfigParamsSafariDestinationConfig{
		Password:        core.StringPtr(password),
		WebsiteURL:      core.StringPtr(websiteURL),
		WebsiteName:     core.StringPtr(websiteName),
		URLFormatString: core.StringPtr(urlFormatString),
		WebsitePushID:   core.StringPtr(websitePushID),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*DestinationConfigParamsSafariDestinationConfig) isaDestinationConfigParams() bool {
	return true
}

// UnmarshalDestinationConfigParamsSafariDestinationConfig unmarshals an instance of DestinationConfigParamsSafariDestinationConfig from the specified map of raw messages.
func UnmarshalDestinationConfigParamsSafariDestinationConfig(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(DestinationConfigParamsSafariDestinationConfig)
	err = core.UnmarshalPrimitive(m, "cert_type", &obj.CertType)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "password", &obj.Password)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "website_url", &obj.WebsiteURL)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "website_name", &obj.WebsiteName)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "url_format_string", &obj.URLFormatString)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "website_push_id", &obj.WebsitePushID)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// DestinationConfigParamsSlackDestinationConfig : Payload describing a slack destination configuration.
// This model "extends" DestinationConfigParams
type DestinationConfigParamsSlackDestinationConfig struct {
	// URL of Slack Incoming Webhook.
	URL *string `json:"url" validate:"required"`
}

// NewDestinationConfigParamsSlackDestinationConfig : Instantiate DestinationConfigParamsSlackDestinationConfig (Generic Model Constructor)
func (*EventNotificationsV1) NewDestinationConfigParamsSlackDestinationConfig(url string) (_model *DestinationConfigParamsSlackDestinationConfig, err error) {
	_model = &DestinationConfigParamsSlackDestinationConfig{
		URL: core.StringPtr(url),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*DestinationConfigParamsSlackDestinationConfig) isaDestinationConfigParams() bool {
	return true
}

// UnmarshalDestinationConfigParamsSlackDestinationConfig unmarshals an instance of DestinationConfigParamsSlackDestinationConfig from the specified map of raw messages.
func UnmarshalDestinationConfigParamsSlackDestinationConfig(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(DestinationConfigParamsSlackDestinationConfig)
	err = core.UnmarshalPrimitive(m, "url", &obj.URL)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// DestinationConfigParamsWebhookDestinationConfig : Payload describing a webhook destination configuration.
// This model "extends" DestinationConfigParams
type DestinationConfigParamsWebhookDestinationConfig struct {
	// URL of webhook.
	URL *string `json:"url" validate:"required"`

	// HTTP method of webhook.
	Verb *string `json:"verb" validate:"required"`

	// Custom headers (Key-Value pair) for webhook call.
	CustomHeaders map[string]string `json:"custom_headers,omitempty"`

	// List of sensitive headers from custom headers.
	SensitiveHeaders []string `json:"sensitive_headers,omitempty"`
}

// Constants associated with the DestinationConfigParamsWebhookDestinationConfig.Verb property.
// HTTP method of webhook.
const (
	DestinationConfigParamsWebhookDestinationConfigVerbGetConst  = "get"
	DestinationConfigParamsWebhookDestinationConfigVerbPostConst = "post"
)

// NewDestinationConfigParamsWebhookDestinationConfig : Instantiate DestinationConfigParamsWebhookDestinationConfig (Generic Model Constructor)
func (*EventNotificationsV1) NewDestinationConfigParamsWebhookDestinationConfig(url string, verb string) (_model *DestinationConfigParamsWebhookDestinationConfig, err error) {
	_model = &DestinationConfigParamsWebhookDestinationConfig{
		URL:  core.StringPtr(url),
		Verb: core.StringPtr(verb),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*DestinationConfigParamsWebhookDestinationConfig) isaDestinationConfigParams() bool {
	return true
}

// UnmarshalDestinationConfigParamsWebhookDestinationConfig unmarshals an instance of DestinationConfigParamsWebhookDestinationConfig from the specified map of raw messages.
func UnmarshalDestinationConfigParamsWebhookDestinationConfig(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(DestinationConfigParamsWebhookDestinationConfig)
	err = core.UnmarshalPrimitive(m, "url", &obj.URL)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "verb", &obj.Verb)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "custom_headers", &obj.CustomHeaders)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "sensitive_headers", &obj.SensitiveHeaders)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SubscriptionAttributesEmailAttributesResponse : The attributes reponse for an email destination.
// This model "extends" SubscriptionAttributes
type SubscriptionAttributesEmailAttributesResponse struct {

	// Allows users to set arbitrary properties
	additionalProperties map[string]interface{}
}

func (*SubscriptionAttributesEmailAttributesResponse) isaSubscriptionAttributes() bool {
	return true
}

// SetProperty allows the user to set an arbitrary property on an instance of SubscriptionAttributesEmailAttributesResponse
func (o *SubscriptionAttributesEmailAttributesResponse) SetProperty(key string, value interface{}) {
	if o.additionalProperties == nil {
		o.additionalProperties = make(map[string]interface{})
	}
	o.additionalProperties[key] = value
}

// SetProperties allows the user to set a map of arbitrary properties on an instance of SubscriptionAttributesEmailAttributesResponse
func (o *SubscriptionAttributesEmailAttributesResponse) SetProperties(m map[string]interface{}) {
	o.additionalProperties = make(map[string]interface{})
	for k, v := range m {
		o.additionalProperties[k] = v
	}
}

// GetProperty allows the user to retrieve an arbitrary property from an instance of SubscriptionAttributesEmailAttributesResponse
func (o *SubscriptionAttributesEmailAttributesResponse) GetProperty(key string) interface{} {
	return o.additionalProperties[key]
}

// GetProperties allows the user to retrieve the map of arbitrary properties from an instance of SubscriptionAttributesEmailAttributesResponse
func (o *SubscriptionAttributesEmailAttributesResponse) GetProperties() map[string]interface{} {
	return o.additionalProperties
}

// MarshalJSON performs custom serialization for instances of SubscriptionAttributesEmailAttributesResponse
func (o *SubscriptionAttributesEmailAttributesResponse) MarshalJSON() (buffer []byte, err error) {
	m := make(map[string]interface{})
	if len(o.additionalProperties) > 0 {
		for k, v := range o.additionalProperties {
			m[k] = v
		}
	}
	buffer, err = json.Marshal(m)
	return
}

// UnmarshalSubscriptionAttributesEmailAttributesResponse unmarshals an instance of SubscriptionAttributesEmailAttributesResponse from the specified map of raw messages.
func UnmarshalSubscriptionAttributesEmailAttributesResponse(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SubscriptionAttributesEmailAttributesResponse)
	for k := range m {
		var v interface{}
		e := core.UnmarshalPrimitive(m, k, &v)
		if e != nil {
			err = e
			return
		}
		obj.SetProperty(k, v)
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SubscriptionAttributesSmsAttributesResponse : SMS attributes object.
// This model "extends" SubscriptionAttributes
type SubscriptionAttributesSmsAttributesResponse struct {

	// Allows users to set arbitrary properties
	additionalProperties map[string]interface{}
}

func (*SubscriptionAttributesSmsAttributesResponse) isaSubscriptionAttributes() bool {
	return true
}

// SetProperty allows the user to set an arbitrary property on an instance of SubscriptionAttributesSmsAttributesResponse
func (o *SubscriptionAttributesSmsAttributesResponse) SetProperty(key string, value interface{}) {
	if o.additionalProperties == nil {
		o.additionalProperties = make(map[string]interface{})
	}
	o.additionalProperties[key] = value
}

// SetProperties allows the user to set a map of arbitrary properties on an instance of SubscriptionAttributesSmsAttributesResponse
func (o *SubscriptionAttributesSmsAttributesResponse) SetProperties(m map[string]interface{}) {
	o.additionalProperties = make(map[string]interface{})
	for k, v := range m {
		o.additionalProperties[k] = v
	}
}

// GetProperty allows the user to retrieve an arbitrary property from an instance of SubscriptionAttributesSmsAttributesResponse
func (o *SubscriptionAttributesSmsAttributesResponse) GetProperty(key string) interface{} {
	return o.additionalProperties[key]
}

// GetProperties allows the user to retrieve the map of arbitrary properties from an instance of SubscriptionAttributesSmsAttributesResponse
func (o *SubscriptionAttributesSmsAttributesResponse) GetProperties() map[string]interface{} {
	return o.additionalProperties
}

// MarshalJSON performs custom serialization for instances of SubscriptionAttributesSmsAttributesResponse
func (o *SubscriptionAttributesSmsAttributesResponse) MarshalJSON() (buffer []byte, err error) {
	m := make(map[string]interface{})
	if len(o.additionalProperties) > 0 {
		for k, v := range o.additionalProperties {
			m[k] = v
		}
	}
	buffer, err = json.Marshal(m)
	return
}

// UnmarshalSubscriptionAttributesSmsAttributesResponse unmarshals an instance of SubscriptionAttributesSmsAttributesResponse from the specified map of raw messages.
func UnmarshalSubscriptionAttributesSmsAttributesResponse(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SubscriptionAttributesSmsAttributesResponse)
	for k := range m {
		var v interface{}
		e := core.UnmarshalPrimitive(m, k, &v)
		if e != nil {
			err = e
			return
		}
		obj.SetProperty(k, v)
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SubscriptionAttributesSlackAttributesResponse : The attributes for a slack notification.
// This model "extends" SubscriptionAttributes
type SubscriptionAttributesSlackAttributesResponse struct {
	// Attachment Color for Slack Notification.
	AttachmentColor *string `json:"attachment_color" validate:"required"`

	// Allows users to set arbitrary properties
	additionalProperties map[string]interface{}
}

func (*SubscriptionAttributesSlackAttributesResponse) isaSubscriptionAttributes() bool {
	return true
}

// SetProperty allows the user to set an arbitrary property on an instance of SubscriptionAttributesSlackAttributesResponse
func (o *SubscriptionAttributesSlackAttributesResponse) SetProperty(key string, value interface{}) {
	if o.additionalProperties == nil {
		o.additionalProperties = make(map[string]interface{})
	}
	o.additionalProperties[key] = value
}

// SetProperties allows the user to set a map of arbitrary properties on an instance of SubscriptionAttributesSlackAttributesResponse
func (o *SubscriptionAttributesSlackAttributesResponse) SetProperties(m map[string]interface{}) {
	o.additionalProperties = make(map[string]interface{})
	for k, v := range m {
		o.additionalProperties[k] = v
	}
}

// GetProperty allows the user to retrieve an arbitrary property from an instance of SubscriptionAttributesSlackAttributesResponse
func (o *SubscriptionAttributesSlackAttributesResponse) GetProperty(key string) interface{} {
	return o.additionalProperties[key]
}

// GetProperties allows the user to retrieve the map of arbitrary properties from an instance of SubscriptionAttributesSlackAttributesResponse
func (o *SubscriptionAttributesSlackAttributesResponse) GetProperties() map[string]interface{} {
	return o.additionalProperties
}

// MarshalJSON performs custom serialization for instances of SubscriptionAttributesSlackAttributesResponse
func (o *SubscriptionAttributesSlackAttributesResponse) MarshalJSON() (buffer []byte, err error) {
	m := make(map[string]interface{})
	if len(o.additionalProperties) > 0 {
		for k, v := range o.additionalProperties {
			m[k] = v
		}
	}
	if o.AttachmentColor != nil {
		m["attachment_color"] = o.AttachmentColor
	}
	buffer, err = json.Marshal(m)
	return
}

// UnmarshalSubscriptionAttributesSlackAttributesResponse unmarshals an instance of SubscriptionAttributesSlackAttributesResponse from the specified map of raw messages.
func UnmarshalSubscriptionAttributesSlackAttributesResponse(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SubscriptionAttributesSlackAttributesResponse)
	err = core.UnmarshalPrimitive(m, "attachment_color", &obj.AttachmentColor)
	if err != nil {
		return
	}
	delete(m, "attachment_color")
	for k := range m {
		var v interface{}
		e := core.UnmarshalPrimitive(m, k, &v)
		if e != nil {
			err = e
			return
		}
		obj.SetProperty(k, v)
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SubscriptionAttributesWebhookAttributesResponse : The attributes for a webhook notification.
// This model "extends" SubscriptionAttributes
type SubscriptionAttributesWebhookAttributesResponse struct {
	// Signing webhook attributes.
	SigningEnabled *bool `json:"signing_enabled" validate:"required"`

	// Decision for Notification Payload to be added.
	AddNotificationPayload *bool `json:"add_notification_payload" validate:"required"`

	// Allows users to set arbitrary properties
	additionalProperties map[string]interface{}
}

func (*SubscriptionAttributesWebhookAttributesResponse) isaSubscriptionAttributes() bool {
	return true
}

// SetProperty allows the user to set an arbitrary property on an instance of SubscriptionAttributesWebhookAttributesResponse
func (o *SubscriptionAttributesWebhookAttributesResponse) SetProperty(key string, value interface{}) {
	if o.additionalProperties == nil {
		o.additionalProperties = make(map[string]interface{})
	}
	o.additionalProperties[key] = value
}

// SetProperties allows the user to set a map of arbitrary properties on an instance of SubscriptionAttributesWebhookAttributesResponse
func (o *SubscriptionAttributesWebhookAttributesResponse) SetProperties(m map[string]interface{}) {
	o.additionalProperties = make(map[string]interface{})
	for k, v := range m {
		o.additionalProperties[k] = v
	}
}

// GetProperty allows the user to retrieve an arbitrary property from an instance of SubscriptionAttributesWebhookAttributesResponse
func (o *SubscriptionAttributesWebhookAttributesResponse) GetProperty(key string) interface{} {
	return o.additionalProperties[key]
}

// GetProperties allows the user to retrieve the map of arbitrary properties from an instance of SubscriptionAttributesWebhookAttributesResponse
func (o *SubscriptionAttributesWebhookAttributesResponse) GetProperties() map[string]interface{} {
	return o.additionalProperties
}

// MarshalJSON performs custom serialization for instances of SubscriptionAttributesWebhookAttributesResponse
func (o *SubscriptionAttributesWebhookAttributesResponse) MarshalJSON() (buffer []byte, err error) {
	m := make(map[string]interface{})
	if len(o.additionalProperties) > 0 {
		for k, v := range o.additionalProperties {
			m[k] = v
		}
	}
	if o.SigningEnabled != nil {
		m["signing_enabled"] = o.SigningEnabled
	}
	if o.AddNotificationPayload != nil {
		m["add_notification_payload"] = o.AddNotificationPayload
	}
	buffer, err = json.Marshal(m)
	return
}

// UnmarshalSubscriptionAttributesWebhookAttributesResponse unmarshals an instance of SubscriptionAttributesWebhookAttributesResponse from the specified map of raw messages.
func UnmarshalSubscriptionAttributesWebhookAttributesResponse(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SubscriptionAttributesWebhookAttributesResponse)
	err = core.UnmarshalPrimitive(m, "signing_enabled", &obj.SigningEnabled)
	if err != nil {
		return
	}
	delete(m, "signing_enabled")
	err = core.UnmarshalPrimitive(m, "add_notification_payload", &obj.AddNotificationPayload)
	if err != nil {
		return
	}
	delete(m, "add_notification_payload")
	for k := range m {
		var v interface{}
		e := core.UnmarshalPrimitive(m, k, &v)
		if e != nil {
			err = e
			return
		}
		obj.SetProperty(k, v)
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SubscriptionCreateAttributesEmailAttributes : The attributes for an email notification.
// This model "extends" SubscriptionCreateAttributes
type SubscriptionCreateAttributesEmailAttributes struct {
	// The email id string.
	To []string `json:"to" validate:"required"`

	// Whether to add the notification payload to the email.
	AddNotificationPayload *bool `json:"add_notification_payload" validate:"required"`

	// The email address to reply to.
	ReplyToMail *string `json:"reply_to_mail" validate:"required"`

	// The email name to reply to.
	ReplyToName *string `json:"reply_to_name" validate:"required"`

	// The email name of From.
	FromName *string `json:"from_name" validate:"required"`
}

// NewSubscriptionCreateAttributesEmailAttributes : Instantiate SubscriptionCreateAttributesEmailAttributes (Generic Model Constructor)
func (*EventNotificationsV1) NewSubscriptionCreateAttributesEmailAttributes(to []string, addNotificationPayload bool, replyToMail string, replyToName string, fromName string) (_model *SubscriptionCreateAttributesEmailAttributes, err error) {
	_model = &SubscriptionCreateAttributesEmailAttributes{
		To:                     to,
		AddNotificationPayload: core.BoolPtr(addNotificationPayload),
		ReplyToMail:            core.StringPtr(replyToMail),
		ReplyToName:            core.StringPtr(replyToName),
		FromName:               core.StringPtr(fromName),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*SubscriptionCreateAttributesEmailAttributes) isaSubscriptionCreateAttributes() bool {
	return true
}

// UnmarshalSubscriptionCreateAttributesEmailAttributes unmarshals an instance of SubscriptionCreateAttributesEmailAttributes from the specified map of raw messages.
func UnmarshalSubscriptionCreateAttributesEmailAttributes(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SubscriptionCreateAttributesEmailAttributes)
	err = core.UnmarshalPrimitive(m, "to", &obj.To)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "add_notification_payload", &obj.AddNotificationPayload)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "reply_to_mail", &obj.ReplyToMail)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "reply_to_name", &obj.ReplyToName)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "from_name", &obj.FromName)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SubscriptionCreateAttributesFcmAttributes : The attributes for an FCM notification.
// This model "extends" SubscriptionCreateAttributes
type SubscriptionCreateAttributesFcmAttributes struct {
}

func (*SubscriptionCreateAttributesFcmAttributes) isaSubscriptionCreateAttributes() bool {
	return true
}

// UnmarshalSubscriptionCreateAttributesFcmAttributes unmarshals an instance of SubscriptionCreateAttributesFcmAttributes from the specified map of raw messages.
func UnmarshalSubscriptionCreateAttributesFcmAttributes(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SubscriptionCreateAttributesFcmAttributes)
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SubscriptionCreateAttributesSmsAttributes : SMS attributes object.
// This model "extends" SubscriptionCreateAttributes
type SubscriptionCreateAttributesSmsAttributes struct {
	// The phone number to send the SMS to.
	To []string `json:"to" validate:"required"`
}

// NewSubscriptionCreateAttributesSmsAttributes : Instantiate SubscriptionCreateAttributesSmsAttributes (Generic Model Constructor)
func (*EventNotificationsV1) NewSubscriptionCreateAttributesSmsAttributes(to []string) (_model *SubscriptionCreateAttributesSmsAttributes, err error) {
	_model = &SubscriptionCreateAttributesSmsAttributes{
		To: to,
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*SubscriptionCreateAttributesSmsAttributes) isaSubscriptionCreateAttributes() bool {
	return true
}

// UnmarshalSubscriptionCreateAttributesSmsAttributes unmarshals an instance of SubscriptionCreateAttributesSmsAttributes from the specified map of raw messages.
func UnmarshalSubscriptionCreateAttributesSmsAttributes(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SubscriptionCreateAttributesSmsAttributes)
	err = core.UnmarshalPrimitive(m, "to", &obj.To)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SubscriptionCreateAttributesSlackAttributes : The attributes for a slack notification.
// This model "extends" SubscriptionCreateAttributes
type SubscriptionCreateAttributesSlackAttributes struct {
	// Attachment Color for the slack message.
	AttachmentColor *string `json:"attachment_color" validate:"required"`
}

// NewSubscriptionCreateAttributesSlackAttributes : Instantiate SubscriptionCreateAttributesSlackAttributes (Generic Model Constructor)
func (*EventNotificationsV1) NewSubscriptionCreateAttributesSlackAttributes(attachmentColor string) (_model *SubscriptionCreateAttributesSlackAttributes, err error) {
	_model = &SubscriptionCreateAttributesSlackAttributes{
		AttachmentColor: core.StringPtr(attachmentColor),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*SubscriptionCreateAttributesSlackAttributes) isaSubscriptionCreateAttributes() bool {
	return true
}

// UnmarshalSubscriptionCreateAttributesSlackAttributes unmarshals an instance of SubscriptionCreateAttributesSlackAttributes from the specified map of raw messages.
func UnmarshalSubscriptionCreateAttributesSlackAttributes(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SubscriptionCreateAttributesSlackAttributes)
	err = core.UnmarshalPrimitive(m, "attachment_color", &obj.AttachmentColor)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SubscriptionCreateAttributesWebhookAttributes : The attributes for a webhook notification.
// This model "extends" SubscriptionCreateAttributes
type SubscriptionCreateAttributesWebhookAttributes struct {
	// Signing webhook attributes.
	SigningEnabled *bool `json:"signing_enabled" validate:"required"`
}

// NewSubscriptionCreateAttributesWebhookAttributes : Instantiate SubscriptionCreateAttributesWebhookAttributes (Generic Model Constructor)
func (*EventNotificationsV1) NewSubscriptionCreateAttributesWebhookAttributes(signingEnabled bool) (_model *SubscriptionCreateAttributesWebhookAttributes, err error) {
	_model = &SubscriptionCreateAttributesWebhookAttributes{
		SigningEnabled: core.BoolPtr(signingEnabled),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*SubscriptionCreateAttributesWebhookAttributes) isaSubscriptionCreateAttributes() bool {
	return true
}

// UnmarshalSubscriptionCreateAttributesWebhookAttributes unmarshals an instance of SubscriptionCreateAttributesWebhookAttributes from the specified map of raw messages.
func UnmarshalSubscriptionCreateAttributesWebhookAttributes(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SubscriptionCreateAttributesWebhookAttributes)
	err = core.UnmarshalPrimitive(m, "signing_enabled", &obj.SigningEnabled)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SubscriptionUpdateAttributesEmailUpdateAttributes : The attributes for an email notification.
// This model "extends" SubscriptionUpdateAttributes
type SubscriptionUpdateAttributesEmailUpdateAttributes struct {
	// The email ids.
	To *EmailUpdateAttributesTo `json:"to" validate:"required"`

	// Whether to add the notification payload to the email.
	AddNotificationPayload *bool `json:"add_notification_payload" validate:"required"`

	// The email address to reply to.
	ReplyToMail *string `json:"reply_to_mail" validate:"required"`

	// The email name to reply to.
	ReplyToName *string `json:"reply_to_name" validate:"required"`

	// The email name of From.
	FromName *string `json:"from_name" validate:"required"`

	// The email ids invited.
	Invited []string `json:"invited,omitempty"`

	// The email ids.
	Unsubscribed *EmailUpdateAttributesUnsubscribed `json:"unsubscribed,omitempty"`
}

// NewSubscriptionUpdateAttributesEmailUpdateAttributes : Instantiate SubscriptionUpdateAttributesEmailUpdateAttributes (Generic Model Constructor)
func (*EventNotificationsV1) NewSubscriptionUpdateAttributesEmailUpdateAttributes(to *EmailUpdateAttributesTo, addNotificationPayload bool, replyToMail string, replyToName string, fromName string) (_model *SubscriptionUpdateAttributesEmailUpdateAttributes, err error) {
	_model = &SubscriptionUpdateAttributesEmailUpdateAttributes{
		To:                     to,
		AddNotificationPayload: core.BoolPtr(addNotificationPayload),
		ReplyToMail:            core.StringPtr(replyToMail),
		ReplyToName:            core.StringPtr(replyToName),
		FromName:               core.StringPtr(fromName),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*SubscriptionUpdateAttributesEmailUpdateAttributes) isaSubscriptionUpdateAttributes() bool {
	return true
}

// UnmarshalSubscriptionUpdateAttributesEmailUpdateAttributes unmarshals an instance of SubscriptionUpdateAttributesEmailUpdateAttributes from the specified map of raw messages.
func UnmarshalSubscriptionUpdateAttributesEmailUpdateAttributes(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SubscriptionUpdateAttributesEmailUpdateAttributes)
	err = core.UnmarshalModel(m, "to", &obj.To, UnmarshalEmailUpdateAttributesTo)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "add_notification_payload", &obj.AddNotificationPayload)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "reply_to_mail", &obj.ReplyToMail)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "reply_to_name", &obj.ReplyToName)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "from_name", &obj.FromName)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "invited", &obj.Invited)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "unsubscribed", &obj.Unsubscribed, UnmarshalEmailUpdateAttributesUnsubscribed)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SubscriptionUpdateAttributesSmsAttributes : SMS attributes object.
// This model "extends" SubscriptionUpdateAttributes
type SubscriptionUpdateAttributesSmsAttributes struct {
	// The phone number to send the SMS to.
	To []string `json:"to" validate:"required"`
}

// NewSubscriptionUpdateAttributesSmsAttributes : Instantiate SubscriptionUpdateAttributesSmsAttributes (Generic Model Constructor)
func (*EventNotificationsV1) NewSubscriptionUpdateAttributesSmsAttributes(to []string) (_model *SubscriptionUpdateAttributesSmsAttributes, err error) {
	_model = &SubscriptionUpdateAttributesSmsAttributes{
		To: to,
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*SubscriptionUpdateAttributesSmsAttributes) isaSubscriptionUpdateAttributes() bool {
	return true
}

// UnmarshalSubscriptionUpdateAttributesSmsAttributes unmarshals an instance of SubscriptionUpdateAttributesSmsAttributes from the specified map of raw messages.
func UnmarshalSubscriptionUpdateAttributesSmsAttributes(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SubscriptionUpdateAttributesSmsAttributes)
	err = core.UnmarshalPrimitive(m, "to", &obj.To)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SubscriptionUpdateAttributesSlackAttributes : The attributes for a slack notification.
// This model "extends" SubscriptionUpdateAttributes
type SubscriptionUpdateAttributesSlackAttributes struct {
	// Attachment Color for the slack message.
	AttachmentColor *string `json:"attachment_color" validate:"required"`
}

// NewSubscriptionUpdateAttributesSlackAttributes : Instantiate SubscriptionUpdateAttributesSlackAttributes (Generic Model Constructor)
func (*EventNotificationsV1) NewSubscriptionUpdateAttributesSlackAttributes(attachmentColor string) (_model *SubscriptionUpdateAttributesSlackAttributes, err error) {
	_model = &SubscriptionUpdateAttributesSlackAttributes{
		AttachmentColor: core.StringPtr(attachmentColor),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*SubscriptionUpdateAttributesSlackAttributes) isaSubscriptionUpdateAttributes() bool {
	return true
}

// UnmarshalSubscriptionUpdateAttributesSlackAttributes unmarshals an instance of SubscriptionUpdateAttributesSlackAttributes from the specified map of raw messages.
func UnmarshalSubscriptionUpdateAttributesSlackAttributes(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SubscriptionUpdateAttributesSlackAttributes)
	err = core.UnmarshalPrimitive(m, "attachment_color", &obj.AttachmentColor)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SubscriptionUpdateAttributesWebhookAttributes : The attributes for a webhook notification.
// This model "extends" SubscriptionUpdateAttributes
type SubscriptionUpdateAttributesWebhookAttributes struct {
	// Signing webhook attributes.
	SigningEnabled *bool `json:"signing_enabled" validate:"required"`
}

// NewSubscriptionUpdateAttributesWebhookAttributes : Instantiate SubscriptionUpdateAttributesWebhookAttributes (Generic Model Constructor)
func (*EventNotificationsV1) NewSubscriptionUpdateAttributesWebhookAttributes(signingEnabled bool) (_model *SubscriptionUpdateAttributesWebhookAttributes, err error) {
	_model = &SubscriptionUpdateAttributesWebhookAttributes{
		SigningEnabled: core.BoolPtr(signingEnabled),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*SubscriptionUpdateAttributesWebhookAttributes) isaSubscriptionUpdateAttributes() bool {
	return true
}

// UnmarshalSubscriptionUpdateAttributesWebhookAttributes unmarshals an instance of SubscriptionUpdateAttributesWebhookAttributes from the specified map of raw messages.
func UnmarshalSubscriptionUpdateAttributesWebhookAttributes(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SubscriptionUpdateAttributesWebhookAttributes)
	err = core.UnmarshalPrimitive(m, "signing_enabled", &obj.SigningEnabled)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}
