/**
 * (C) Copyright IBM Corp. 2021.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*
 * IBM OpenAPI SDK Code Generator Version: 3.41.0-f1ef0102-20211018-193503
 */

// Package eventnotificationsv1 : Operations and models for the EventNotificationsV1 service
package eventnotificationsv1

import (
	"context"
	"encoding/json"
	"fmt"
	"net/http"
	"reflect"
	"time"

	common "github.com/IBM/event-notifications-go-admin-sdk/common"
	"github.com/IBM/go-sdk-core/v5/core"
	"github.com/go-openapi/strfmt"
)

// EventNotificationsV1 : No description provided (generated by Openapi Generator
// https://github.com/openapitools/openapi-generator)
//
// API Version: 1.0
type EventNotificationsV1 struct {
	Service *core.BaseService
}

// DefaultServiceURL is the default URL to make service requests to.
const DefaultServiceURL = "https://notifications-dev-02072d4876b4d118c3c99d947398ca94-0001.us-south.containers.appdomain.cloud/event-notifications"

// DefaultServiceName is the default key used to find external configuration information.
const DefaultServiceName = "event_notifications"

// EventNotificationsV1Options : Service options
type EventNotificationsV1Options struct {
	ServiceName   string
	URL           string
	Authenticator core.Authenticator
}

// NewEventNotificationsV1UsingExternalConfig : constructs an instance of EventNotificationsV1 with passed in options and external configuration.
func NewEventNotificationsV1UsingExternalConfig(options *EventNotificationsV1Options) (eventNotifications *EventNotificationsV1, err error) {
	if options.ServiceName == "" {
		options.ServiceName = DefaultServiceName
	}

	if options.Authenticator == nil {
		options.Authenticator, err = core.GetAuthenticatorFromEnvironment(options.ServiceName)
		if err != nil {
			return
		}
	}

	eventNotifications, err = NewEventNotificationsV1(options)
	if err != nil {
		return
	}

	err = eventNotifications.Service.ConfigureService(options.ServiceName)
	if err != nil {
		return
	}

	if options.URL != "" {
		err = eventNotifications.Service.SetServiceURL(options.URL)
	}
	return
}

// NewEventNotificationsV1 : constructs an instance of EventNotificationsV1 with passed in options.
func NewEventNotificationsV1(options *EventNotificationsV1Options) (service *EventNotificationsV1, err error) {
	serviceOptions := &core.ServiceOptions{
		URL:           DefaultServiceURL,
		Authenticator: options.Authenticator,
	}

	baseService, err := core.NewBaseService(serviceOptions)
	if err != nil {
		return
	}

	if options.URL != "" {
		err = baseService.SetServiceURL(options.URL)
		if err != nil {
			return
		}
	}

	service = &EventNotificationsV1{
		Service: baseService,
	}

	return
}

// GetServiceURLForRegion returns the service URL to be used for the specified region
func GetServiceURLForRegion(region string) (string, error) {
	return "", fmt.Errorf("service does not support regional URLs")
}

// Clone makes a copy of "eventNotifications" suitable for processing requests.
func (eventNotifications *EventNotificationsV1) Clone() *EventNotificationsV1 {
	if core.IsNil(eventNotifications) {
		return nil
	}
	clone := *eventNotifications
	clone.Service = eventNotifications.Service.Clone()
	return &clone
}

// SetServiceURL sets the service URL
func (eventNotifications *EventNotificationsV1) SetServiceURL(url string) error {
	return eventNotifications.Service.SetServiceURL(url)
}

// GetServiceURL returns the service URL
func (eventNotifications *EventNotificationsV1) GetServiceURL() string {
	return eventNotifications.Service.GetServiceURL()
}

// SetDefaultHeaders sets HTTP headers to be sent in every request
func (eventNotifications *EventNotificationsV1) SetDefaultHeaders(headers http.Header) {
	eventNotifications.Service.SetDefaultHeaders(headers)
}

// SetEnableGzipCompression sets the service's EnableGzipCompression field
func (eventNotifications *EventNotificationsV1) SetEnableGzipCompression(enableGzip bool) {
	eventNotifications.Service.SetEnableGzipCompression(enableGzip)
}

// GetEnableGzipCompression returns the service's EnableGzipCompression field
func (eventNotifications *EventNotificationsV1) GetEnableGzipCompression() bool {
	return eventNotifications.Service.GetEnableGzipCompression()
}

// EnableRetries enables automatic retries for requests invoked for this service instance.
// If either parameter is specified as 0, then a default value is used instead.
func (eventNotifications *EventNotificationsV1) EnableRetries(maxRetries int, maxRetryInterval time.Duration) {
	eventNotifications.Service.EnableRetries(maxRetries, maxRetryInterval)
}

// DisableRetries disables automatic retries for requests invoked for this service instance.
func (eventNotifications *EventNotificationsV1) DisableRetries() {
	eventNotifications.Service.DisableRetries()
}

// ListSources : List all Sources
// List all Sources.
func (eventNotifications *EventNotificationsV1) ListSources(listSourcesOptions *ListSourcesOptions) (result *SourceList, response *core.DetailedResponse, err error) {
	return eventNotifications.ListSourcesWithContext(context.Background(), listSourcesOptions)
}

// ListSourcesWithContext is an alternate form of the ListSources method which supports a Context parameter
func (eventNotifications *EventNotificationsV1) ListSourcesWithContext(ctx context.Context, listSourcesOptions *ListSourcesOptions) (result *SourceList, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(listSourcesOptions, "listSourcesOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(listSourcesOptions, "listSourcesOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"instance_id": *listSourcesOptions.InstanceID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = eventNotifications.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(eventNotifications.Service.Options.URL, `/v1/instances/{instance_id}/sources`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range listSourcesOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("event_notifications", "V1", "ListSources")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	if listSourcesOptions.Limit != nil {
		builder.AddQuery("limit", fmt.Sprint(*listSourcesOptions.Limit))
	}
	if listSourcesOptions.Offset != nil {
		builder.AddQuery("offset", fmt.Sprint(*listSourcesOptions.Offset))
	}
	if listSourcesOptions.Search != nil {
		builder.AddQuery("search", fmt.Sprint(*listSourcesOptions.Search))
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = eventNotifications.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalSourceList)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// GetSource : Get a Source
// Get a Sources.
func (eventNotifications *EventNotificationsV1) GetSource(getSourceOptions *GetSourceOptions) (result *Source, response *core.DetailedResponse, err error) {
	return eventNotifications.GetSourceWithContext(context.Background(), getSourceOptions)
}

// GetSourceWithContext is an alternate form of the GetSource method which supports a Context parameter
func (eventNotifications *EventNotificationsV1) GetSourceWithContext(ctx context.Context, getSourceOptions *GetSourceOptions) (result *Source, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getSourceOptions, "getSourceOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getSourceOptions, "getSourceOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"instance_id": *getSourceOptions.InstanceID,
		"id":          *getSourceOptions.ID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = eventNotifications.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(eventNotifications.Service.Options.URL, `/v1/instances/{instance_id}/sources/{id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range getSourceOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("event_notifications", "V1", "GetSource")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = eventNotifications.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalSource)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// CreateTopic : Create a new Topic
// Create a new Topic.
func (eventNotifications *EventNotificationsV1) CreateTopic(createTopicOptions *CreateTopicOptions) (result *TopicResponse, response *core.DetailedResponse, err error) {
	return eventNotifications.CreateTopicWithContext(context.Background(), createTopicOptions)
}

// CreateTopicWithContext is an alternate form of the CreateTopic method which supports a Context parameter
func (eventNotifications *EventNotificationsV1) CreateTopicWithContext(ctx context.Context, createTopicOptions *CreateTopicOptions) (result *TopicResponse, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(createTopicOptions, "createTopicOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(createTopicOptions, "createTopicOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"instance_id": *createTopicOptions.InstanceID,
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = eventNotifications.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(eventNotifications.Service.Options.URL, `/v1/instances/{instance_id}/topics`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range createTopicOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("event_notifications", "V1", "CreateTopic")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	body := make(map[string]interface{})
	if createTopicOptions.Name != nil {
		body["name"] = createTopicOptions.Name
	}
	if createTopicOptions.Description != nil {
		body["description"] = createTopicOptions.Description
	}
	if createTopicOptions.Sources != nil {
		body["sources"] = createTopicOptions.Sources
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = eventNotifications.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalTopicResponse)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// ListTopics : List all Topics
// List all Topics.
func (eventNotifications *EventNotificationsV1) ListTopics(listTopicsOptions *ListTopicsOptions) (result *TopicList, response *core.DetailedResponse, err error) {
	return eventNotifications.ListTopicsWithContext(context.Background(), listTopicsOptions)
}

// ListTopicsWithContext is an alternate form of the ListTopics method which supports a Context parameter
func (eventNotifications *EventNotificationsV1) ListTopicsWithContext(ctx context.Context, listTopicsOptions *ListTopicsOptions) (result *TopicList, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(listTopicsOptions, "listTopicsOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(listTopicsOptions, "listTopicsOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"instance_id": *listTopicsOptions.InstanceID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = eventNotifications.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(eventNotifications.Service.Options.URL, `/v1/instances/{instance_id}/topics`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range listTopicsOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("event_notifications", "V1", "ListTopics")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	if listTopicsOptions.Limit != nil {
		builder.AddQuery("limit", fmt.Sprint(*listTopicsOptions.Limit))
	}
	if listTopicsOptions.Offset != nil {
		builder.AddQuery("offset", fmt.Sprint(*listTopicsOptions.Offset))
	}
	if listTopicsOptions.Search != nil {
		builder.AddQuery("search", fmt.Sprint(*listTopicsOptions.Search))
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = eventNotifications.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalTopicList)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// GetTopic : Get details of a Topic
// Get details of a Topic.
func (eventNotifications *EventNotificationsV1) GetTopic(getTopicOptions *GetTopicOptions) (result *Topic, response *core.DetailedResponse, err error) {
	return eventNotifications.GetTopicWithContext(context.Background(), getTopicOptions)
}

// GetTopicWithContext is an alternate form of the GetTopic method which supports a Context parameter
func (eventNotifications *EventNotificationsV1) GetTopicWithContext(ctx context.Context, getTopicOptions *GetTopicOptions) (result *Topic, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getTopicOptions, "getTopicOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getTopicOptions, "getTopicOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"instance_id": *getTopicOptions.InstanceID,
		"id":          *getTopicOptions.ID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = eventNotifications.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(eventNotifications.Service.Options.URL, `/v1/instances/{instance_id}/topics/{id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range getTopicOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("event_notifications", "V1", "GetTopic")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	if getTopicOptions.Include != nil {
		builder.AddQuery("include", fmt.Sprint(*getTopicOptions.Include))
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = eventNotifications.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalTopic)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// ReplaceTopic : Update details of a Topic
// Update details of a Topic.
func (eventNotifications *EventNotificationsV1) ReplaceTopic(replaceTopicOptions *ReplaceTopicOptions) (result *Topic, response *core.DetailedResponse, err error) {
	return eventNotifications.ReplaceTopicWithContext(context.Background(), replaceTopicOptions)
}

// ReplaceTopicWithContext is an alternate form of the ReplaceTopic method which supports a Context parameter
func (eventNotifications *EventNotificationsV1) ReplaceTopicWithContext(ctx context.Context, replaceTopicOptions *ReplaceTopicOptions) (result *Topic, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(replaceTopicOptions, "replaceTopicOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(replaceTopicOptions, "replaceTopicOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"instance_id": *replaceTopicOptions.InstanceID,
		"id":          *replaceTopicOptions.ID,
	}

	builder := core.NewRequestBuilder(core.PUT)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = eventNotifications.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(eventNotifications.Service.Options.URL, `/v1/instances/{instance_id}/topics/{id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range replaceTopicOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("event_notifications", "V1", "ReplaceTopic")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	body := make(map[string]interface{})
	if replaceTopicOptions.Name != nil {
		body["name"] = replaceTopicOptions.Name
	}
	if replaceTopicOptions.Description != nil {
		body["description"] = replaceTopicOptions.Description
	}
	if replaceTopicOptions.Sources != nil {
		body["sources"] = replaceTopicOptions.Sources
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = eventNotifications.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalTopic)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// DeleteTopic : Delete a Topic
// Delete a Topic.
func (eventNotifications *EventNotificationsV1) DeleteTopic(deleteTopicOptions *DeleteTopicOptions) (response *core.DetailedResponse, err error) {
	return eventNotifications.DeleteTopicWithContext(context.Background(), deleteTopicOptions)
}

// DeleteTopicWithContext is an alternate form of the DeleteTopic method which supports a Context parameter
func (eventNotifications *EventNotificationsV1) DeleteTopicWithContext(ctx context.Context, deleteTopicOptions *DeleteTopicOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(deleteTopicOptions, "deleteTopicOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(deleteTopicOptions, "deleteTopicOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"instance_id": *deleteTopicOptions.InstanceID,
		"id":          *deleteTopicOptions.ID,
	}

	builder := core.NewRequestBuilder(core.DELETE)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = eventNotifications.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(eventNotifications.Service.Options.URL, `/v1/instances/{instance_id}/topics/{id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range deleteTopicOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("event_notifications", "V1", "DeleteTopic")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = eventNotifications.Service.Request(request, nil)

	return
}

// CreateDestination : Create a new Destination
// Create a new Destination.
func (eventNotifications *EventNotificationsV1) CreateDestination(createDestinationOptions *CreateDestinationOptions) (result *DestinationResponse, response *core.DetailedResponse, err error) {
	return eventNotifications.CreateDestinationWithContext(context.Background(), createDestinationOptions)
}

// CreateDestinationWithContext is an alternate form of the CreateDestination method which supports a Context parameter
func (eventNotifications *EventNotificationsV1) CreateDestinationWithContext(ctx context.Context, createDestinationOptions *CreateDestinationOptions) (result *DestinationResponse, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(createDestinationOptions, "createDestinationOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(createDestinationOptions, "createDestinationOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"instance_id": *createDestinationOptions.InstanceID,
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = eventNotifications.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(eventNotifications.Service.Options.URL, `/v1/instances/{instance_id}/destinations`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range createDestinationOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("event_notifications", "V1", "CreateDestination")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	body := make(map[string]interface{})
	if createDestinationOptions.Name != nil {
		body["name"] = createDestinationOptions.Name
	}
	if createDestinationOptions.Type != nil {
		body["type"] = createDestinationOptions.Type
	}
	if createDestinationOptions.Description != nil {
		body["description"] = createDestinationOptions.Description
	}
	if createDestinationOptions.Config != nil {
		body["config"] = createDestinationOptions.Config
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = eventNotifications.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalDestinationResponse)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// ListDestinations : List all Destinations
// List all Destinations.
func (eventNotifications *EventNotificationsV1) ListDestinations(listDestinationsOptions *ListDestinationsOptions) (result *DestinationList, response *core.DetailedResponse, err error) {
	return eventNotifications.ListDestinationsWithContext(context.Background(), listDestinationsOptions)
}

// ListDestinationsWithContext is an alternate form of the ListDestinations method which supports a Context parameter
func (eventNotifications *EventNotificationsV1) ListDestinationsWithContext(ctx context.Context, listDestinationsOptions *ListDestinationsOptions) (result *DestinationList, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(listDestinationsOptions, "listDestinationsOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(listDestinationsOptions, "listDestinationsOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"instance_id": *listDestinationsOptions.InstanceID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = eventNotifications.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(eventNotifications.Service.Options.URL, `/v1/instances/{instance_id}/destinations`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range listDestinationsOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("event_notifications", "V1", "ListDestinations")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	if listDestinationsOptions.Limit != nil {
		builder.AddQuery("limit", fmt.Sprint(*listDestinationsOptions.Limit))
	}
	if listDestinationsOptions.Offset != nil {
		builder.AddQuery("offset", fmt.Sprint(*listDestinationsOptions.Offset))
	}
	if listDestinationsOptions.Search != nil {
		builder.AddQuery("search", fmt.Sprint(*listDestinationsOptions.Search))
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = eventNotifications.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalDestinationList)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// GetDestination : Get details of a Destination
// Get details of a Destination.
func (eventNotifications *EventNotificationsV1) GetDestination(getDestinationOptions *GetDestinationOptions) (result *Destination, response *core.DetailedResponse, err error) {
	return eventNotifications.GetDestinationWithContext(context.Background(), getDestinationOptions)
}

// GetDestinationWithContext is an alternate form of the GetDestination method which supports a Context parameter
func (eventNotifications *EventNotificationsV1) GetDestinationWithContext(ctx context.Context, getDestinationOptions *GetDestinationOptions) (result *Destination, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getDestinationOptions, "getDestinationOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getDestinationOptions, "getDestinationOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"instance_id": *getDestinationOptions.InstanceID,
		"id":          *getDestinationOptions.ID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = eventNotifications.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(eventNotifications.Service.Options.URL, `/v1/instances/{instance_id}/destinations/{id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range getDestinationOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("event_notifications", "V1", "GetDestination")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = eventNotifications.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalDestination)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// UpdateDestination : Update details of a Destination
// Update details of a Destination.
func (eventNotifications *EventNotificationsV1) UpdateDestination(updateDestinationOptions *UpdateDestinationOptions) (result *Destination, response *core.DetailedResponse, err error) {
	return eventNotifications.UpdateDestinationWithContext(context.Background(), updateDestinationOptions)
}

// UpdateDestinationWithContext is an alternate form of the UpdateDestination method which supports a Context parameter
func (eventNotifications *EventNotificationsV1) UpdateDestinationWithContext(ctx context.Context, updateDestinationOptions *UpdateDestinationOptions) (result *Destination, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(updateDestinationOptions, "updateDestinationOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(updateDestinationOptions, "updateDestinationOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"instance_id": *updateDestinationOptions.InstanceID,
		"id":          *updateDestinationOptions.ID,
	}

	builder := core.NewRequestBuilder(core.PATCH)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = eventNotifications.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(eventNotifications.Service.Options.URL, `/v1/instances/{instance_id}/destinations/{id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range updateDestinationOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("event_notifications", "V1", "UpdateDestination")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	body := make(map[string]interface{})
	if updateDestinationOptions.Name != nil {
		body["name"] = updateDestinationOptions.Name
	}
	if updateDestinationOptions.Description != nil {
		body["description"] = updateDestinationOptions.Description
	}
	if updateDestinationOptions.Config != nil {
		body["config"] = updateDestinationOptions.Config
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = eventNotifications.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalDestination)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// DeleteDestination : Delete a Destination
// Delete a Destination.
func (eventNotifications *EventNotificationsV1) DeleteDestination(deleteDestinationOptions *DeleteDestinationOptions) (response *core.DetailedResponse, err error) {
	return eventNotifications.DeleteDestinationWithContext(context.Background(), deleteDestinationOptions)
}

// DeleteDestinationWithContext is an alternate form of the DeleteDestination method which supports a Context parameter
func (eventNotifications *EventNotificationsV1) DeleteDestinationWithContext(ctx context.Context, deleteDestinationOptions *DeleteDestinationOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(deleteDestinationOptions, "deleteDestinationOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(deleteDestinationOptions, "deleteDestinationOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"instance_id": *deleteDestinationOptions.InstanceID,
		"id":          *deleteDestinationOptions.ID,
	}

	builder := core.NewRequestBuilder(core.DELETE)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = eventNotifications.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(eventNotifications.Service.Options.URL, `/v1/instances/{instance_id}/destinations/{id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range deleteDestinationOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("event_notifications", "V1", "DeleteDestination")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = eventNotifications.Service.Request(request, nil)

	return
}

// CreateSubscription : Create a new Subscription
// Create a new Subscription.
func (eventNotifications *EventNotificationsV1) CreateSubscription(createSubscriptionOptions *CreateSubscriptionOptions) (result *Subscription, response *core.DetailedResponse, err error) {
	return eventNotifications.CreateSubscriptionWithContext(context.Background(), createSubscriptionOptions)
}

// CreateSubscriptionWithContext is an alternate form of the CreateSubscription method which supports a Context parameter
func (eventNotifications *EventNotificationsV1) CreateSubscriptionWithContext(ctx context.Context, createSubscriptionOptions *CreateSubscriptionOptions) (result *Subscription, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(createSubscriptionOptions, "createSubscriptionOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(createSubscriptionOptions, "createSubscriptionOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"instance_id": *createSubscriptionOptions.InstanceID,
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = eventNotifications.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(eventNotifications.Service.Options.URL, `/v1/instances/{instance_id}/subscriptions`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range createSubscriptionOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("event_notifications", "V1", "CreateSubscription")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	body := make(map[string]interface{})
	if createSubscriptionOptions.Name != nil {
		body["name"] = createSubscriptionOptions.Name
	}
	if createSubscriptionOptions.DestinationID != nil {
		body["destination_id"] = createSubscriptionOptions.DestinationID
	}
	if createSubscriptionOptions.TopicID != nil {
		body["topic_id"] = createSubscriptionOptions.TopicID
	}
	if createSubscriptionOptions.Attributes != nil {
		body["attributes"] = createSubscriptionOptions.Attributes
	}
	if createSubscriptionOptions.Description != nil {
		body["description"] = createSubscriptionOptions.Description
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = eventNotifications.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalSubscription)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// ListSubscriptions : List all Subscriptions
// List all Subscriptions.
func (eventNotifications *EventNotificationsV1) ListSubscriptions(listSubscriptionsOptions *ListSubscriptionsOptions) (result *SubscriptionList, response *core.DetailedResponse, err error) {
	return eventNotifications.ListSubscriptionsWithContext(context.Background(), listSubscriptionsOptions)
}

// ListSubscriptionsWithContext is an alternate form of the ListSubscriptions method which supports a Context parameter
func (eventNotifications *EventNotificationsV1) ListSubscriptionsWithContext(ctx context.Context, listSubscriptionsOptions *ListSubscriptionsOptions) (result *SubscriptionList, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(listSubscriptionsOptions, "listSubscriptionsOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(listSubscriptionsOptions, "listSubscriptionsOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"instance_id": *listSubscriptionsOptions.InstanceID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = eventNotifications.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(eventNotifications.Service.Options.URL, `/v1/instances/{instance_id}/subscriptions`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range listSubscriptionsOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("event_notifications", "V1", "ListSubscriptions")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	if listSubscriptionsOptions.Offset != nil {
		builder.AddQuery("offset", fmt.Sprint(*listSubscriptionsOptions.Offset))
	}
	if listSubscriptionsOptions.Limit != nil {
		builder.AddQuery("limit", fmt.Sprint(*listSubscriptionsOptions.Limit))
	}
	if listSubscriptionsOptions.Search != nil {
		builder.AddQuery("search", fmt.Sprint(*listSubscriptionsOptions.Search))
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = eventNotifications.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalSubscriptionList)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// GetSubscription : Get details of a Subscription
// Get details of a Subscription.
func (eventNotifications *EventNotificationsV1) GetSubscription(getSubscriptionOptions *GetSubscriptionOptions) (result *Subscription, response *core.DetailedResponse, err error) {
	return eventNotifications.GetSubscriptionWithContext(context.Background(), getSubscriptionOptions)
}

// GetSubscriptionWithContext is an alternate form of the GetSubscription method which supports a Context parameter
func (eventNotifications *EventNotificationsV1) GetSubscriptionWithContext(ctx context.Context, getSubscriptionOptions *GetSubscriptionOptions) (result *Subscription, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getSubscriptionOptions, "getSubscriptionOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getSubscriptionOptions, "getSubscriptionOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"instance_id": *getSubscriptionOptions.InstanceID,
		"id":          *getSubscriptionOptions.ID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = eventNotifications.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(eventNotifications.Service.Options.URL, `/v1/instances/{instance_id}/subscriptions/{id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range getSubscriptionOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("event_notifications", "V1", "GetSubscription")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = eventNotifications.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalSubscription)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// DeleteSubscription : Delete a Subscription
// Delete a Subscription.
func (eventNotifications *EventNotificationsV1) DeleteSubscription(deleteSubscriptionOptions *DeleteSubscriptionOptions) (response *core.DetailedResponse, err error) {
	return eventNotifications.DeleteSubscriptionWithContext(context.Background(), deleteSubscriptionOptions)
}

// DeleteSubscriptionWithContext is an alternate form of the DeleteSubscription method which supports a Context parameter
func (eventNotifications *EventNotificationsV1) DeleteSubscriptionWithContext(ctx context.Context, deleteSubscriptionOptions *DeleteSubscriptionOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(deleteSubscriptionOptions, "deleteSubscriptionOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(deleteSubscriptionOptions, "deleteSubscriptionOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"instance_id": *deleteSubscriptionOptions.InstanceID,
		"id":          *deleteSubscriptionOptions.ID,
	}

	builder := core.NewRequestBuilder(core.DELETE)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = eventNotifications.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(eventNotifications.Service.Options.URL, `/v1/instances/{instance_id}/subscriptions/{id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range deleteSubscriptionOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("event_notifications", "V1", "DeleteSubscription")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = eventNotifications.Service.Request(request, nil)

	return
}

// UpdateSubscription : Update details of a Subscription
// Update details of a Subscription.
func (eventNotifications *EventNotificationsV1) UpdateSubscription(updateSubscriptionOptions *UpdateSubscriptionOptions) (result *Subscription, response *core.DetailedResponse, err error) {
	return eventNotifications.UpdateSubscriptionWithContext(context.Background(), updateSubscriptionOptions)
}

// UpdateSubscriptionWithContext is an alternate form of the UpdateSubscription method which supports a Context parameter
func (eventNotifications *EventNotificationsV1) UpdateSubscriptionWithContext(ctx context.Context, updateSubscriptionOptions *UpdateSubscriptionOptions) (result *Subscription, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(updateSubscriptionOptions, "updateSubscriptionOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(updateSubscriptionOptions, "updateSubscriptionOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"instance_id": *updateSubscriptionOptions.InstanceID,
		"id":          *updateSubscriptionOptions.ID,
	}

	builder := core.NewRequestBuilder(core.PATCH)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = eventNotifications.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(eventNotifications.Service.Options.URL, `/v1/instances/{instance_id}/subscriptions/{id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range updateSubscriptionOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("event_notifications", "V1", "UpdateSubscription")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	body := make(map[string]interface{})
	if updateSubscriptionOptions.Name != nil {
		body["name"] = updateSubscriptionOptions.Name
	}
	if updateSubscriptionOptions.Description != nil {
		body["description"] = updateSubscriptionOptions.Description
	}
	if updateSubscriptionOptions.Attributes != nil {
		body["attributes"] = updateSubscriptionOptions.Attributes
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = eventNotifications.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalSubscription)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// CreateDestinationOptions : The CreateDestination options.
type CreateDestinationOptions struct {
	// Unique identifier for IBM Cloud Event Notifications instance.
	InstanceID *string `json:"instance_id" validate:"required,ne="`

	// The Destintion name.
	Name *string `json:"name" validate:"required"`

	// The type of Destination Webhook.
	Type *string `json:"type" validate:"required"`

	// The Destination description.
	Description *string `json:"description,omitempty"`

	// Payload describing a destination configuration.
	Config *DestinationConfig `json:"config,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// Constants associated with the CreateDestinationOptions.Type property.
// The type of Destination Webhook.
const (
	CreateDestinationOptionsTypeWebhookConst = "webhook"
)

// NewCreateDestinationOptions : Instantiate CreateDestinationOptions
func (*EventNotificationsV1) NewCreateDestinationOptions(instanceID string, name string, typeVar string) *CreateDestinationOptions {
	return &CreateDestinationOptions{
		InstanceID: core.StringPtr(instanceID),
		Name:       core.StringPtr(name),
		Type:       core.StringPtr(typeVar),
	}
}

// SetInstanceID : Allow user to set InstanceID
func (_options *CreateDestinationOptions) SetInstanceID(instanceID string) *CreateDestinationOptions {
	_options.InstanceID = core.StringPtr(instanceID)
	return _options
}

// SetName : Allow user to set Name
func (_options *CreateDestinationOptions) SetName(name string) *CreateDestinationOptions {
	_options.Name = core.StringPtr(name)
	return _options
}

// SetType : Allow user to set Type
func (_options *CreateDestinationOptions) SetType(typeVar string) *CreateDestinationOptions {
	_options.Type = core.StringPtr(typeVar)
	return _options
}

// SetDescription : Allow user to set Description
func (_options *CreateDestinationOptions) SetDescription(description string) *CreateDestinationOptions {
	_options.Description = core.StringPtr(description)
	return _options
}

// SetConfig : Allow user to set Config
func (_options *CreateDestinationOptions) SetConfig(config *DestinationConfig) *CreateDestinationOptions {
	_options.Config = config
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *CreateDestinationOptions) SetHeaders(param map[string]string) *CreateDestinationOptions {
	options.Headers = param
	return options
}

// CreateSubscriptionOptions : The CreateSubscription options.
type CreateSubscriptionOptions struct {
	// Unique identifier for IBM Cloud Event Notifications instance.
	InstanceID *string `json:"instance_id" validate:"required,ne="`

	// Subscription name.
	Name *string `json:"name" validate:"required"`

	// Destination ID.
	DestinationID *string `json:"destination_id" validate:"required"`

	// Topic ID.
	TopicID *string `json:"topic_id" validate:"required"`

	Attributes SubscriptionCreateAttributesIntf `json:"attributes" validate:"required"`

	// Subscription description.
	Description *string `json:"description,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewCreateSubscriptionOptions : Instantiate CreateSubscriptionOptions
func (*EventNotificationsV1) NewCreateSubscriptionOptions(instanceID string, name string, destinationID string, topicID string, attributes SubscriptionCreateAttributesIntf) *CreateSubscriptionOptions {
	return &CreateSubscriptionOptions{
		InstanceID:    core.StringPtr(instanceID),
		Name:          core.StringPtr(name),
		DestinationID: core.StringPtr(destinationID),
		TopicID:       core.StringPtr(topicID),
		Attributes:    attributes,
	}
}

// SetInstanceID : Allow user to set InstanceID
func (_options *CreateSubscriptionOptions) SetInstanceID(instanceID string) *CreateSubscriptionOptions {
	_options.InstanceID = core.StringPtr(instanceID)
	return _options
}

// SetName : Allow user to set Name
func (_options *CreateSubscriptionOptions) SetName(name string) *CreateSubscriptionOptions {
	_options.Name = core.StringPtr(name)
	return _options
}

// SetDestinationID : Allow user to set DestinationID
func (_options *CreateSubscriptionOptions) SetDestinationID(destinationID string) *CreateSubscriptionOptions {
	_options.DestinationID = core.StringPtr(destinationID)
	return _options
}

// SetTopicID : Allow user to set TopicID
func (_options *CreateSubscriptionOptions) SetTopicID(topicID string) *CreateSubscriptionOptions {
	_options.TopicID = core.StringPtr(topicID)
	return _options
}

// SetAttributes : Allow user to set Attributes
func (_options *CreateSubscriptionOptions) SetAttributes(attributes SubscriptionCreateAttributesIntf) *CreateSubscriptionOptions {
	_options.Attributes = attributes
	return _options
}

// SetDescription : Allow user to set Description
func (_options *CreateSubscriptionOptions) SetDescription(description string) *CreateSubscriptionOptions {
	_options.Description = core.StringPtr(description)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *CreateSubscriptionOptions) SetHeaders(param map[string]string) *CreateSubscriptionOptions {
	options.Headers = param
	return options
}

// CreateTopicOptions : The CreateTopic options.
type CreateTopicOptions struct {
	// Unique identifier for IBM Cloud Event Notifications instance.
	InstanceID *string `json:"instance_id" validate:"required,ne="`

	// Name of the topic.
	Name *string `json:"name" validate:"required"`

	// Description of the topic.
	Description *string `json:"description,omitempty"`

	// List of sources.
	Sources []TopicUpdateSourcesItem `json:"sources,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewCreateTopicOptions : Instantiate CreateTopicOptions
func (*EventNotificationsV1) NewCreateTopicOptions(instanceID string, name string) *CreateTopicOptions {
	return &CreateTopicOptions{
		InstanceID: core.StringPtr(instanceID),
		Name:       core.StringPtr(name),
	}
}

// SetInstanceID : Allow user to set InstanceID
func (_options *CreateTopicOptions) SetInstanceID(instanceID string) *CreateTopicOptions {
	_options.InstanceID = core.StringPtr(instanceID)
	return _options
}

// SetName : Allow user to set Name
func (_options *CreateTopicOptions) SetName(name string) *CreateTopicOptions {
	_options.Name = core.StringPtr(name)
	return _options
}

// SetDescription : Allow user to set Description
func (_options *CreateTopicOptions) SetDescription(description string) *CreateTopicOptions {
	_options.Description = core.StringPtr(description)
	return _options
}

// SetSources : Allow user to set Sources
func (_options *CreateTopicOptions) SetSources(sources []TopicUpdateSourcesItem) *CreateTopicOptions {
	_options.Sources = sources
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *CreateTopicOptions) SetHeaders(param map[string]string) *CreateTopicOptions {
	options.Headers = param
	return options
}

// DeleteDestinationOptions : The DeleteDestination options.
type DeleteDestinationOptions struct {
	// Unique identifier for IBM Cloud Event Notifications instance.
	InstanceID *string `json:"instance_id" validate:"required,ne="`

	// Unique identifier for Destination.
	ID *string `json:"id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewDeleteDestinationOptions : Instantiate DeleteDestinationOptions
func (*EventNotificationsV1) NewDeleteDestinationOptions(instanceID string, id string) *DeleteDestinationOptions {
	return &DeleteDestinationOptions{
		InstanceID: core.StringPtr(instanceID),
		ID:         core.StringPtr(id),
	}
}

// SetInstanceID : Allow user to set InstanceID
func (_options *DeleteDestinationOptions) SetInstanceID(instanceID string) *DeleteDestinationOptions {
	_options.InstanceID = core.StringPtr(instanceID)
	return _options
}

// SetID : Allow user to set ID
func (_options *DeleteDestinationOptions) SetID(id string) *DeleteDestinationOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *DeleteDestinationOptions) SetHeaders(param map[string]string) *DeleteDestinationOptions {
	options.Headers = param
	return options
}

// DeleteSubscriptionOptions : The DeleteSubscription options.
type DeleteSubscriptionOptions struct {
	// Unique identifier for IBM Cloud Event Notifications instance.
	InstanceID *string `json:"instance_id" validate:"required,ne="`

	// Unique identifier for Subscription.
	ID *string `json:"id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewDeleteSubscriptionOptions : Instantiate DeleteSubscriptionOptions
func (*EventNotificationsV1) NewDeleteSubscriptionOptions(instanceID string, id string) *DeleteSubscriptionOptions {
	return &DeleteSubscriptionOptions{
		InstanceID: core.StringPtr(instanceID),
		ID:         core.StringPtr(id),
	}
}

// SetInstanceID : Allow user to set InstanceID
func (_options *DeleteSubscriptionOptions) SetInstanceID(instanceID string) *DeleteSubscriptionOptions {
	_options.InstanceID = core.StringPtr(instanceID)
	return _options
}

// SetID : Allow user to set ID
func (_options *DeleteSubscriptionOptions) SetID(id string) *DeleteSubscriptionOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *DeleteSubscriptionOptions) SetHeaders(param map[string]string) *DeleteSubscriptionOptions {
	options.Headers = param
	return options
}

// DeleteTopicOptions : The DeleteTopic options.
type DeleteTopicOptions struct {
	// Unique identifier for IBM Cloud Event Notifications instance.
	InstanceID *string `json:"instance_id" validate:"required,ne="`

	// Unique identifier for Topic.
	ID *string `json:"id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewDeleteTopicOptions : Instantiate DeleteTopicOptions
func (*EventNotificationsV1) NewDeleteTopicOptions(instanceID string, id string) *DeleteTopicOptions {
	return &DeleteTopicOptions{
		InstanceID: core.StringPtr(instanceID),
		ID:         core.StringPtr(id),
	}
}

// SetInstanceID : Allow user to set InstanceID
func (_options *DeleteTopicOptions) SetInstanceID(instanceID string) *DeleteTopicOptions {
	_options.InstanceID = core.StringPtr(instanceID)
	return _options
}

// SetID : Allow user to set ID
func (_options *DeleteTopicOptions) SetID(id string) *DeleteTopicOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *DeleteTopicOptions) SetHeaders(param map[string]string) *DeleteTopicOptions {
	options.Headers = param
	return options
}

// Destination : Payload describing a destination get request.
type Destination struct {
	// Destination ID.
	ID *string `json:"id" validate:"required"`

	// Destination name.
	Name *string `json:"name" validate:"required"`

	// Destination description.
	Description *string `json:"description" validate:"required"`

	// Destination type Email/SMS/Webhook.
	Type *string `json:"type" validate:"required"`

	// Payload describing a destination configuration.
	Config *DestinationConfig `json:"config,omitempty"`

	// Last updated time.
	UpdatedAt *strfmt.DateTime `json:"updated_at" validate:"required"`

	// Number of subscriptions.
	SubscriptionCount *int64 `json:"subscription_count" validate:"required"`

	// List of subscriptions.
	SubscriptionNames []string `json:"subscription_names" validate:"required"`
}

// Constants associated with the Destination.Type property.
// Destination type Email/SMS/Webhook.
const (
	DestinationTypeSMTPIBMConst = "smtp_ibm"
	DestinationTypeSmsIBMConst  = "sms_ibm"
	DestinationTypeWebhookConst = "webhook"
)

// UnmarshalDestination unmarshals an instance of Destination from the specified map of raw messages.
func UnmarshalDestination(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(Destination)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "description", &obj.Description)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "config", &obj.Config, UnmarshalDestinationConfig)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "updated_at", &obj.UpdatedAt)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "subscription_count", &obj.SubscriptionCount)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "subscription_names", &obj.SubscriptionNames)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// DestinationConfig : Payload describing a destination configuration.
type DestinationConfig struct {
	Params DestinationConfigParamsIntf `json:"params" validate:"required"`
}

// NewDestinationConfig : Instantiate DestinationConfig (Generic Model Constructor)
func (*EventNotificationsV1) NewDestinationConfig(params DestinationConfigParamsIntf) (_model *DestinationConfig, err error) {
	_model = &DestinationConfig{
		Params: params,
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

// UnmarshalDestinationConfig unmarshals an instance of DestinationConfig from the specified map of raw messages.
func UnmarshalDestinationConfig(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(DestinationConfig)
	err = core.UnmarshalModel(m, "params", &obj.Params, UnmarshalDestinationConfigParams)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// DestinationConfigParams : DestinationConfigParams struct
// Models which "extend" this model:
// - DestinationConfigParamsWebhookDestinationConfig
type DestinationConfigParams struct {
	// URL of webhook.
	URL *string `json:"url,omitempty"`

	// HTTP method of webhook.
	Verb *string `json:"verb,omitempty"`

	// Custom headers (Key-Value pair) for webhook call.
	CustomHeaders map[string]string `json:"custom_headers,omitempty"`

	// List of sensitive headers from custom headers.
	SensitiveHeaders []string `json:"sensitive_headers,omitempty"`
}

// Constants associated with the DestinationConfigParams.Verb property.
// HTTP method of webhook.
const (
	DestinationConfigParamsVerbGetConst  = "get"
	DestinationConfigParamsVerbPostConst = "post"
)

func (*DestinationConfigParams) isaDestinationConfigParams() bool {
	return true
}

type DestinationConfigParamsIntf interface {
	isaDestinationConfigParams() bool
}

// UnmarshalDestinationConfigParams unmarshals an instance of DestinationConfigParams from the specified map of raw messages.
func UnmarshalDestinationConfigParams(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(DestinationConfigParams)
	err = core.UnmarshalPrimitive(m, "url", &obj.URL)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "verb", &obj.Verb)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "custom_headers", &obj.CustomHeaders)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "sensitive_headers", &obj.SensitiveHeaders)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// DestinationLisItem : Destination object.
type DestinationLisItem struct {
	// Destination ID.
	ID *string `json:"id" validate:"required"`

	// Destination name.
	Name *string `json:"name" validate:"required"`

	// Destination description.
	Description *string `json:"description" validate:"required"`

	// Destination type Email/SMS/Webhook.
	Type *string `json:"type" validate:"required"`

	// Subscription count.
	SubscriptionCount *int64 `json:"subscription_count" validate:"required"`

	// Names of subscriptions.
	SubscriptionNames []string `json:"subscription_names" validate:"required"`

	// Updated at.
	UpdatedAt *strfmt.DateTime `json:"updated_at" validate:"required"`
}

// Constants associated with the DestinationLisItem.Type property.
// Destination type Email/SMS/Webhook.
const (
	DestinationLisItemTypeSMTPIBMConst = "smtp_ibm"
	DestinationLisItemTypeSmsIBMConst  = "sms_ibm"
	DestinationLisItemTypeWebhookConst = "webhook"
)

// UnmarshalDestinationLisItem unmarshals an instance of DestinationLisItem from the specified map of raw messages.
func UnmarshalDestinationLisItem(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(DestinationLisItem)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "description", &obj.Description)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "subscription_count", &obj.SubscriptionCount)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "subscription_names", &obj.SubscriptionNames)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "updated_at", &obj.UpdatedAt)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// DestinationList : Payload describing a destination list request.
type DestinationList struct {
	// Total number of destinations.
	TotalCount *int64 `json:"total_count" validate:"required"`

	// Current offset.
	Offset *int64 `json:"offset" validate:"required"`

	// limit to show destinations.
	Limit *int64 `json:"limit" validate:"required"`

	// List of destinations.
	Destinations []DestinationLisItem `json:"destinations" validate:"required"`
}

// UnmarshalDestinationList unmarshals an instance of DestinationList from the specified map of raw messages.
func UnmarshalDestinationList(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(DestinationList)
	err = core.UnmarshalPrimitive(m, "total_count", &obj.TotalCount)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "offset", &obj.Offset)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "limit", &obj.Limit)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "destinations", &obj.Destinations, UnmarshalDestinationLisItem)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// DestinationResponse : Payload describing a destination get request.
type DestinationResponse struct {
	// Destination ID.
	ID *string `json:"id" validate:"required"`

	// Destination name.
	Name *string `json:"name" validate:"required"`

	// Destination description.
	Description *string `json:"description" validate:"required"`

	// Destination type Email/SMS/Webhook.
	Type *string `json:"type" validate:"required"`

	// Payload describing a destination configuration.
	Config *DestinationConfig `json:"config" validate:"required"`

	// Last updated time.
	CreatedAt *strfmt.DateTime `json:"created_at" validate:"required"`
}

// Constants associated with the DestinationResponse.Type property.
// Destination type Email/SMS/Webhook.
const (
	DestinationResponseTypeWebhookConst = "webhook"
)

// UnmarshalDestinationResponse unmarshals an instance of DestinationResponse from the specified map of raw messages.
func UnmarshalDestinationResponse(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(DestinationResponse)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "description", &obj.Description)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "config", &obj.Config, UnmarshalDestinationConfig)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "created_at", &obj.CreatedAt)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// GetDestinationOptions : The GetDestination options.
type GetDestinationOptions struct {
	// Unique identifier for IBM Cloud Event Notifications instance.
	InstanceID *string `json:"instance_id" validate:"required,ne="`

	// Unique identifier for Destination.
	ID *string `json:"id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetDestinationOptions : Instantiate GetDestinationOptions
func (*EventNotificationsV1) NewGetDestinationOptions(instanceID string, id string) *GetDestinationOptions {
	return &GetDestinationOptions{
		InstanceID: core.StringPtr(instanceID),
		ID:         core.StringPtr(id),
	}
}

// SetInstanceID : Allow user to set InstanceID
func (_options *GetDestinationOptions) SetInstanceID(instanceID string) *GetDestinationOptions {
	_options.InstanceID = core.StringPtr(instanceID)
	return _options
}

// SetID : Allow user to set ID
func (_options *GetDestinationOptions) SetID(id string) *GetDestinationOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *GetDestinationOptions) SetHeaders(param map[string]string) *GetDestinationOptions {
	options.Headers = param
	return options
}

// GetSourceOptions : The GetSource options.
type GetSourceOptions struct {
	// Unique identifier for IBM Cloud Event Notifications instance.
	InstanceID *string `json:"instance_id" validate:"required,ne="`

	// Unique identifier for Source.
	ID *string `json:"id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetSourceOptions : Instantiate GetSourceOptions
func (*EventNotificationsV1) NewGetSourceOptions(instanceID string, id string) *GetSourceOptions {
	return &GetSourceOptions{
		InstanceID: core.StringPtr(instanceID),
		ID:         core.StringPtr(id),
	}
}

// SetInstanceID : Allow user to set InstanceID
func (_options *GetSourceOptions) SetInstanceID(instanceID string) *GetSourceOptions {
	_options.InstanceID = core.StringPtr(instanceID)
	return _options
}

// SetID : Allow user to set ID
func (_options *GetSourceOptions) SetID(id string) *GetSourceOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *GetSourceOptions) SetHeaders(param map[string]string) *GetSourceOptions {
	options.Headers = param
	return options
}

// GetSubscriptionOptions : The GetSubscription options.
type GetSubscriptionOptions struct {
	// Unique identifier for IBM Cloud Event Notifications instance.
	InstanceID *string `json:"instance_id" validate:"required,ne="`

	// Unique identifier for Subscription.
	ID *string `json:"id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetSubscriptionOptions : Instantiate GetSubscriptionOptions
func (*EventNotificationsV1) NewGetSubscriptionOptions(instanceID string, id string) *GetSubscriptionOptions {
	return &GetSubscriptionOptions{
		InstanceID: core.StringPtr(instanceID),
		ID:         core.StringPtr(id),
	}
}

// SetInstanceID : Allow user to set InstanceID
func (_options *GetSubscriptionOptions) SetInstanceID(instanceID string) *GetSubscriptionOptions {
	_options.InstanceID = core.StringPtr(instanceID)
	return _options
}

// SetID : Allow user to set ID
func (_options *GetSubscriptionOptions) SetID(id string) *GetSubscriptionOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *GetSubscriptionOptions) SetHeaders(param map[string]string) *GetSubscriptionOptions {
	options.Headers = param
	return options
}

// GetTopicOptions : The GetTopic options.
type GetTopicOptions struct {
	// Unique identifier for IBM Cloud Event Notifications instance.
	InstanceID *string `json:"instance_id" validate:"required,ne="`

	// Unique identifier for Topic.
	ID *string `json:"id" validate:"required,ne="`

	// Include sub topics.
	Include *string `json:"include,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetTopicOptions : Instantiate GetTopicOptions
func (*EventNotificationsV1) NewGetTopicOptions(instanceID string, id string) *GetTopicOptions {
	return &GetTopicOptions{
		InstanceID: core.StringPtr(instanceID),
		ID:         core.StringPtr(id),
	}
}

// SetInstanceID : Allow user to set InstanceID
func (_options *GetTopicOptions) SetInstanceID(instanceID string) *GetTopicOptions {
	_options.InstanceID = core.StringPtr(instanceID)
	return _options
}

// SetID : Allow user to set ID
func (_options *GetTopicOptions) SetID(id string) *GetTopicOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetInclude : Allow user to set Include
func (_options *GetTopicOptions) SetInclude(include string) *GetTopicOptions {
	_options.Include = core.StringPtr(include)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *GetTopicOptions) SetHeaders(param map[string]string) *GetTopicOptions {
	options.Headers = param
	return options
}

// ListDestinationsOptions : The ListDestinations options.
type ListDestinationsOptions struct {
	// Unique identifier for IBM Cloud Event Notifications instance.
	InstanceID *string `json:"instance_id" validate:"required,ne="`

	// Page limit for paginated results.
	Limit *int64 `json:"limit,omitempty"`

	// offset for paginated results.
	Offset *int64 `json:"offset,omitempty"`

	// Search string for filtering results.
	Search *string `json:"search,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewListDestinationsOptions : Instantiate ListDestinationsOptions
func (*EventNotificationsV1) NewListDestinationsOptions(instanceID string) *ListDestinationsOptions {
	return &ListDestinationsOptions{
		InstanceID: core.StringPtr(instanceID),
	}
}

// SetInstanceID : Allow user to set InstanceID
func (_options *ListDestinationsOptions) SetInstanceID(instanceID string) *ListDestinationsOptions {
	_options.InstanceID = core.StringPtr(instanceID)
	return _options
}

// SetLimit : Allow user to set Limit
func (_options *ListDestinationsOptions) SetLimit(limit int64) *ListDestinationsOptions {
	_options.Limit = core.Int64Ptr(limit)
	return _options
}

// SetOffset : Allow user to set Offset
func (_options *ListDestinationsOptions) SetOffset(offset int64) *ListDestinationsOptions {
	_options.Offset = core.Int64Ptr(offset)
	return _options
}

// SetSearch : Allow user to set Search
func (_options *ListDestinationsOptions) SetSearch(search string) *ListDestinationsOptions {
	_options.Search = core.StringPtr(search)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *ListDestinationsOptions) SetHeaders(param map[string]string) *ListDestinationsOptions {
	options.Headers = param
	return options
}

// ListSourcesOptions : The ListSources options.
type ListSourcesOptions struct {
	// Unique identifier for IBM Cloud Event Notifications instance.
	InstanceID *string `json:"instance_id" validate:"required,ne="`

	// Page limit for paginated results.
	Limit *int64 `json:"limit,omitempty"`

	// offset for paginated results.
	Offset *int64 `json:"offset,omitempty"`

	// Search string for filtering results.
	Search *string `json:"search,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewListSourcesOptions : Instantiate ListSourcesOptions
func (*EventNotificationsV1) NewListSourcesOptions(instanceID string) *ListSourcesOptions {
	return &ListSourcesOptions{
		InstanceID: core.StringPtr(instanceID),
	}
}

// SetInstanceID : Allow user to set InstanceID
func (_options *ListSourcesOptions) SetInstanceID(instanceID string) *ListSourcesOptions {
	_options.InstanceID = core.StringPtr(instanceID)
	return _options
}

// SetLimit : Allow user to set Limit
func (_options *ListSourcesOptions) SetLimit(limit int64) *ListSourcesOptions {
	_options.Limit = core.Int64Ptr(limit)
	return _options
}

// SetOffset : Allow user to set Offset
func (_options *ListSourcesOptions) SetOffset(offset int64) *ListSourcesOptions {
	_options.Offset = core.Int64Ptr(offset)
	return _options
}

// SetSearch : Allow user to set Search
func (_options *ListSourcesOptions) SetSearch(search string) *ListSourcesOptions {
	_options.Search = core.StringPtr(search)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *ListSourcesOptions) SetHeaders(param map[string]string) *ListSourcesOptions {
	options.Headers = param
	return options
}

// ListSubscriptionsOptions : The ListSubscriptions options.
type ListSubscriptionsOptions struct {
	// Unique identifier for IBM Cloud Event Notifications instance.
	InstanceID *string `json:"instance_id" validate:"required,ne="`

	// offset for paginated results.
	Offset *int64 `json:"offset,omitempty"`

	// Page limit for paginated results.
	Limit *int64 `json:"limit,omitempty"`

	// Search string for filtering results.
	Search *string `json:"search,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewListSubscriptionsOptions : Instantiate ListSubscriptionsOptions
func (*EventNotificationsV1) NewListSubscriptionsOptions(instanceID string) *ListSubscriptionsOptions {
	return &ListSubscriptionsOptions{
		InstanceID: core.StringPtr(instanceID),
	}
}

// SetInstanceID : Allow user to set InstanceID
func (_options *ListSubscriptionsOptions) SetInstanceID(instanceID string) *ListSubscriptionsOptions {
	_options.InstanceID = core.StringPtr(instanceID)
	return _options
}

// SetOffset : Allow user to set Offset
func (_options *ListSubscriptionsOptions) SetOffset(offset int64) *ListSubscriptionsOptions {
	_options.Offset = core.Int64Ptr(offset)
	return _options
}

// SetLimit : Allow user to set Limit
func (_options *ListSubscriptionsOptions) SetLimit(limit int64) *ListSubscriptionsOptions {
	_options.Limit = core.Int64Ptr(limit)
	return _options
}

// SetSearch : Allow user to set Search
func (_options *ListSubscriptionsOptions) SetSearch(search string) *ListSubscriptionsOptions {
	_options.Search = core.StringPtr(search)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *ListSubscriptionsOptions) SetHeaders(param map[string]string) *ListSubscriptionsOptions {
	options.Headers = param
	return options
}

// ListTopicsOptions : The ListTopics options.
type ListTopicsOptions struct {
	// Unique identifier for IBM Cloud Event Notifications instance.
	InstanceID *string `json:"instance_id" validate:"required,ne="`

	// Page limit for paginated results.
	Limit *int64 `json:"limit,omitempty"`

	// offset for paginated results.
	Offset *int64 `json:"offset,omitempty"`

	// Search string for filtering results.
	Search *string `json:"search,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewListTopicsOptions : Instantiate ListTopicsOptions
func (*EventNotificationsV1) NewListTopicsOptions(instanceID string) *ListTopicsOptions {
	return &ListTopicsOptions{
		InstanceID: core.StringPtr(instanceID),
	}
}

// SetInstanceID : Allow user to set InstanceID
func (_options *ListTopicsOptions) SetInstanceID(instanceID string) *ListTopicsOptions {
	_options.InstanceID = core.StringPtr(instanceID)
	return _options
}

// SetLimit : Allow user to set Limit
func (_options *ListTopicsOptions) SetLimit(limit int64) *ListTopicsOptions {
	_options.Limit = core.Int64Ptr(limit)
	return _options
}

// SetOffset : Allow user to set Offset
func (_options *ListTopicsOptions) SetOffset(offset int64) *ListTopicsOptions {
	_options.Offset = core.Int64Ptr(offset)
	return _options
}

// SetSearch : Allow user to set Search
func (_options *ListTopicsOptions) SetSearch(search string) *ListTopicsOptions {
	_options.Search = core.StringPtr(search)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *ListTopicsOptions) SetHeaders(param map[string]string) *ListTopicsOptions {
	options.Headers = param
	return options
}

// ReplaceTopicOptions : The ReplaceTopic options.
type ReplaceTopicOptions struct {
	// Unique identifier for IBM Cloud Event Notifications instance.
	InstanceID *string `json:"instance_id" validate:"required,ne="`

	// Unique identifier for Topic.
	ID *string `json:"id" validate:"required,ne="`

	// Name of the topic.
	Name *string `json:"name,omitempty"`

	// Description of the topic.
	Description *string `json:"description,omitempty"`

	// List of sources.
	Sources []TopicUpdateSourcesItem `json:"sources,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewReplaceTopicOptions : Instantiate ReplaceTopicOptions
func (*EventNotificationsV1) NewReplaceTopicOptions(instanceID string, id string) *ReplaceTopicOptions {
	return &ReplaceTopicOptions{
		InstanceID: core.StringPtr(instanceID),
		ID:         core.StringPtr(id),
	}
}

// SetInstanceID : Allow user to set InstanceID
func (_options *ReplaceTopicOptions) SetInstanceID(instanceID string) *ReplaceTopicOptions {
	_options.InstanceID = core.StringPtr(instanceID)
	return _options
}

// SetID : Allow user to set ID
func (_options *ReplaceTopicOptions) SetID(id string) *ReplaceTopicOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetName : Allow user to set Name
func (_options *ReplaceTopicOptions) SetName(name string) *ReplaceTopicOptions {
	_options.Name = core.StringPtr(name)
	return _options
}

// SetDescription : Allow user to set Description
func (_options *ReplaceTopicOptions) SetDescription(description string) *ReplaceTopicOptions {
	_options.Description = core.StringPtr(description)
	return _options
}

// SetSources : Allow user to set Sources
func (_options *ReplaceTopicOptions) SetSources(sources []TopicUpdateSourcesItem) *ReplaceTopicOptions {
	_options.Sources = sources
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *ReplaceTopicOptions) SetHeaders(param map[string]string) *ReplaceTopicOptions {
	options.Headers = param
	return options
}

// Rules : Rule object.
type Rules struct {
	// Whether the rule is enabled or not.
	Enabled *bool `json:"enabled,omitempty"`

	// Event type filter.
	EventTypeFilter *string `json:"event_type_filter" validate:"required"`

	// Notification filter.
	NotificationFilter *string `json:"notification_filter,omitempty"`
}

// NewRules : Instantiate Rules (Generic Model Constructor)
func (*EventNotificationsV1) NewRules(eventTypeFilter string) (_model *Rules, err error) {
	_model = &Rules{
		EventTypeFilter: core.StringPtr(eventTypeFilter),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

// UnmarshalRules unmarshals an instance of Rules from the specified map of raw messages.
func UnmarshalRules(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(Rules)
	err = core.UnmarshalPrimitive(m, "enabled", &obj.Enabled)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "event_type_filter", &obj.EventTypeFilter)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "notification_filter", &obj.NotificationFilter)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// RulesGet : Rule object.
type RulesGet struct {
	// Whether the rule is enabled or not.
	Enabled *bool `json:"enabled" validate:"required"`

	// Event type filter.
	EventTypeFilter *string `json:"event_type_filter" validate:"required"`

	// Notification filter.
	NotificationFilter *string `json:"notification_filter" validate:"required"`

	// Last time the topic was updated.
	UpdatedAt *string `json:"updated_at" validate:"required"`

	// Autogenerated rule ID.
	ID *string `json:"id" validate:"required"`
}

// UnmarshalRulesGet unmarshals an instance of RulesGet from the specified map of raw messages.
func UnmarshalRulesGet(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(RulesGet)
	err = core.UnmarshalPrimitive(m, "enabled", &obj.Enabled)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "event_type_filter", &obj.EventTypeFilter)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "notification_filter", &obj.NotificationFilter)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "updated_at", &obj.UpdatedAt)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// Source : Payload describing a source generate request.
type Source struct {
	// The id of the source.
	ID *string `json:"id" validate:"required"`

	// The name of the source.
	Name *string `json:"name" validate:"required"`

	// The description of the source.
	Description *string `json:"description" validate:"required"`

	// The status of the source.
	Enabled *bool `json:"enabled" validate:"required"`

	// Type of the source.
	Type *string `json:"type" validate:"required"`

	// The last updated time of the source.
	UpdatedAt *strfmt.DateTime `json:"updated_at" validate:"required"`

	// The number of topics.
	TopicCount *int64 `json:"topic_count" validate:"required"`

	// The names of the topics.
	TopicNames []string `json:"topic_names" validate:"required"`
}

// UnmarshalSource unmarshals an instance of Source from the specified map of raw messages.
func UnmarshalSource(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(Source)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "description", &obj.Description)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "enabled", &obj.Enabled)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "updated_at", &obj.UpdatedAt)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "topic_count", &obj.TopicCount)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "topic_names", &obj.TopicNames)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SourceList : Payload describing a source list request.
type SourceList struct {
	// Number of sources.
	TotalCount *int64 `json:"total_count" validate:"required"`

	// Current offset.
	Offset *int64 `json:"offset" validate:"required"`

	// limit to show sources.
	Limit *int64 `json:"limit" validate:"required"`

	// List of sources.
	Sources []SourcesListItem `json:"sources" validate:"required"`
}

// UnmarshalSourceList unmarshals an instance of SourceList from the specified map of raw messages.
func UnmarshalSourceList(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SourceList)
	err = core.UnmarshalPrimitive(m, "total_count", &obj.TotalCount)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "offset", &obj.Offset)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "limit", &obj.Limit)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "sources", &obj.Sources, UnmarshalSourcesListItem)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SourcesListItem : Payload describing a source list item.
type SourcesListItem struct {
	// ID of the source.
	ID *string `json:"id" validate:"required"`

	// Name of the source.
	Name *string `json:"name" validate:"required"`

	// Description of the source.
	Description *string `json:"description" validate:"required"`

	// Type of the source.
	Type *string `json:"type" validate:"required"`

	// Whether the source is enabled or not.
	Enabled *bool `json:"enabled" validate:"required"`

	// Time of the last update.
	UpdatedAt *strfmt.DateTime `json:"updated_at" validate:"required"`

	// Number of topics.
	TopicCount *int64 `json:"topic_count" validate:"required"`
}

// UnmarshalSourcesListItem unmarshals an instance of SourcesListItem from the specified map of raw messages.
func UnmarshalSourcesListItem(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SourcesListItem)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "description", &obj.Description)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "enabled", &obj.Enabled)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "updated_at", &obj.UpdatedAt)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "topic_count", &obj.TopicCount)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// Subscription : Subscription object.
type Subscription struct {
	// Subscription ID.
	ID *string `json:"id" validate:"required"`

	// Subscription name.
	Name *string `json:"name" validate:"required"`

	// Subscription description.
	Description *string `json:"description" validate:"required"`

	// Last updated time.
	UpdatedAt *string `json:"updated_at" validate:"required"`

	// From Email ID (it will be displayed only in case of smtp_ibm destination type).
	From *string `json:"from,omitempty"`

	// The type of destination.
	DestinationType *string `json:"destination_type" validate:"required"`

	// The destination ID.
	DestinationID *string `json:"destination_id" validate:"required"`

	// The destination name.
	DestinationName *string `json:"destination_name" validate:"required"`

	// Topic ID.
	TopicID *string `json:"topic_id" validate:"required"`

	// Topic name.
	TopicName *string `json:"topic_name" validate:"required"`

	Attributes SubscriptionAttributesIntf `json:"attributes" validate:"required"`

	// Allows users to set arbitrary properties
	additionalProperties map[string]interface{}
}

// Constants associated with the Subscription.DestinationType property.
// The type of destination.
const (
	SubscriptionDestinationTypeSMTPIBMConst = "smtp_ibm"
	SubscriptionDestinationTypeSmsIBMConst  = "sms_ibm"
	SubscriptionDestinationTypeWebhookConst = "webhook"
)

// SetProperty allows the user to set an arbitrary property on an instance of Subscription
func (o *Subscription) SetProperty(key string, value interface{}) {
	if o.additionalProperties == nil {
		o.additionalProperties = make(map[string]interface{})
	}
	o.additionalProperties[key] = value
}

// SetProperties allows the user to set a map of arbitrary properties on an instance of Subscription
func (o *Subscription) SetProperties(m map[string]interface{}) {
	o.additionalProperties = make(map[string]interface{})
	for k, v := range m {
		o.additionalProperties[k] = v
	}
}

// GetProperty allows the user to retrieve an arbitrary property from an instance of Subscription
func (o *Subscription) GetProperty(key string) interface{} {
	return o.additionalProperties[key]
}

// GetProperties allows the user to retrieve the map of arbitrary properties from an instance of Subscription
func (o *Subscription) GetProperties() map[string]interface{} {
	return o.additionalProperties
}

// MarshalJSON performs custom serialization for instances of Subscription
func (o *Subscription) MarshalJSON() (buffer []byte, err error) {
	m := make(map[string]interface{})
	if len(o.additionalProperties) > 0 {
		for k, v := range o.additionalProperties {
			m[k] = v
		}
	}
	if o.ID != nil {
		m["id"] = o.ID
	}
	if o.Name != nil {
		m["name"] = o.Name
	}
	if o.Description != nil {
		m["description"] = o.Description
	}
	if o.UpdatedAt != nil {
		m["updated_at"] = o.UpdatedAt
	}
	if o.From != nil {
		m["from"] = o.From
	}
	if o.DestinationType != nil {
		m["destination_type"] = o.DestinationType
	}
	if o.DestinationID != nil {
		m["destination_id"] = o.DestinationID
	}
	if o.DestinationName != nil {
		m["destination_name"] = o.DestinationName
	}
	if o.TopicID != nil {
		m["topic_id"] = o.TopicID
	}
	if o.TopicName != nil {
		m["topic_name"] = o.TopicName
	}
	if o.Attributes != nil {
		m["attributes"] = o.Attributes
	}
	buffer, err = json.Marshal(m)
	return
}

// UnmarshalSubscription unmarshals an instance of Subscription from the specified map of raw messages.
func UnmarshalSubscription(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(Subscription)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	delete(m, "id")
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	delete(m, "name")
	err = core.UnmarshalPrimitive(m, "description", &obj.Description)
	if err != nil {
		return
	}
	delete(m, "description")
	err = core.UnmarshalPrimitive(m, "updated_at", &obj.UpdatedAt)
	if err != nil {
		return
	}
	delete(m, "updated_at")
	err = core.UnmarshalPrimitive(m, "from", &obj.From)
	if err != nil {
		return
	}
	delete(m, "from")
	err = core.UnmarshalPrimitive(m, "destination_type", &obj.DestinationType)
	if err != nil {
		return
	}
	delete(m, "destination_type")
	err = core.UnmarshalPrimitive(m, "destination_id", &obj.DestinationID)
	if err != nil {
		return
	}
	delete(m, "destination_id")
	err = core.UnmarshalPrimitive(m, "destination_name", &obj.DestinationName)
	if err != nil {
		return
	}
	delete(m, "destination_name")
	err = core.UnmarshalPrimitive(m, "topic_id", &obj.TopicID)
	if err != nil {
		return
	}
	delete(m, "topic_id")
	err = core.UnmarshalPrimitive(m, "topic_name", &obj.TopicName)
	if err != nil {
		return
	}
	delete(m, "topic_name")
	err = core.UnmarshalModel(m, "attributes", &obj.Attributes, UnmarshalSubscriptionAttributes)
	if err != nil {
		return
	}
	delete(m, "attributes")
	for k := range m {
		var v interface{}
		e := core.UnmarshalPrimitive(m, k, &v)
		if e != nil {
			err = e
			return
		}
		obj.SetProperty(k, v)
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SubscriptionAttributes : SubscriptionAttributes struct
// Models which "extend" this model:
// - SubscriptionAttributesSmsAttributesResponse
// - SubscriptionAttributesEmailAttributesResponse
// - SubscriptionAttributesWebhookAttributesResponse
type SubscriptionAttributes struct {
	// The phone number to send the SMS to.
	To []string `json:"to,omitempty"`

	// The recipient selection method.
	RecipientSelection *string `json:"recipient_selection,omitempty"`

	// Whether to add the notification payload to the email.
	AddNotificationPayload *bool `json:"add_notification_payload,omitempty"`

	// The email address to reply to.
	ReplyTo *string `json:"reply_to,omitempty"`

	// Signing webhook attributes.
	SigningEnabled *bool `json:"signing_enabled,omitempty"`
}

func (*SubscriptionAttributes) isaSubscriptionAttributes() bool {
	return true
}

type SubscriptionAttributesIntf interface {
	isaSubscriptionAttributes() bool
}

// UnmarshalSubscriptionAttributes unmarshals an instance of SubscriptionAttributes from the specified map of raw messages.
func UnmarshalSubscriptionAttributes(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SubscriptionAttributes)
	err = core.UnmarshalPrimitive(m, "to", &obj.To)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "recipient_selection", &obj.RecipientSelection)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "add_notification_payload", &obj.AddNotificationPayload)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "reply_to", &obj.ReplyTo)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "signing_enabled", &obj.SigningEnabled)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SubscriptionCreateAttributes : SubscriptionCreateAttributes struct
// Models which "extend" this model:
// - SubscriptionCreateAttributesSmsAttributes
// - SubscriptionCreateAttributesEmailAttributes
// - SubscriptionCreateAttributesWebhookAttributes
type SubscriptionCreateAttributes struct {
	// The phone number to send the SMS to.
	To []string `json:"to,omitempty"`

	// Whether to add the notification payload to the email.
	AddNotificationPayload *bool `json:"add_notification_payload,omitempty"`

	// The email address to reply to.
	ReplyTo *string `json:"reply_to,omitempty"`

	// Signing webhook attributes.
	SigningEnabled *bool `json:"signing_enabled,omitempty"`
}

func (*SubscriptionCreateAttributes) isaSubscriptionCreateAttributes() bool {
	return true
}

type SubscriptionCreateAttributesIntf interface {
	isaSubscriptionCreateAttributes() bool
}

// UnmarshalSubscriptionCreateAttributes unmarshals an instance of SubscriptionCreateAttributes from the specified map of raw messages.
func UnmarshalSubscriptionCreateAttributes(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SubscriptionCreateAttributes)
	err = core.UnmarshalPrimitive(m, "to", &obj.To)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "add_notification_payload", &obj.AddNotificationPayload)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "reply_to", &obj.ReplyTo)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "signing_enabled", &obj.SigningEnabled)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SubscriptionList : Subscription list object.
type SubscriptionList struct {
	// Number of subscriptions.
	TotalCount *int64 `json:"total_count" validate:"required"`

	// Current offset.
	Offset *int64 `json:"offset" validate:"required"`

	// limit to show subscriptions.
	Limit *int64 `json:"limit" validate:"required"`

	// List of subscriptions.
	Subscriptions []SubscriptionListItem `json:"subscriptions" validate:"required"`
}

// UnmarshalSubscriptionList unmarshals an instance of SubscriptionList from the specified map of raw messages.
func UnmarshalSubscriptionList(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SubscriptionList)
	err = core.UnmarshalPrimitive(m, "total_count", &obj.TotalCount)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "offset", &obj.Offset)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "limit", &obj.Limit)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "subscriptions", &obj.Subscriptions, UnmarshalSubscriptionListItem)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SubscriptionListItem : Subscription list item.
type SubscriptionListItem struct {
	// ID of the subscription.
	ID *string `json:"id" validate:"required"`

	// Name of the subscription.
	Name *string `json:"name" validate:"required"`

	// Description of the subscription.
	Description *string `json:"description" validate:"required"`

	// ID of the destination.
	DestinationID *string `json:"destination_id" validate:"required"`

	// Name of the destination.
	DestinationName *string `json:"destination_name,omitempty"`

	// The type of destination.
	DestinationType *string `json:"destination_type" validate:"required"`

	// ID of the topic.
	TopicID *string `json:"topic_id" validate:"required"`

	// Name of the topic.
	TopicName *string `json:"topic_name,omitempty"`

	// Last updated time of the subscription.
	UpdatedAt *strfmt.DateTime `json:"updated_at" validate:"required"`
}

// Constants associated with the SubscriptionListItem.DestinationType property.
// The type of destination.
const (
	SubscriptionListItemDestinationTypeSMTPIBMConst = "smtp_ibm"
	SubscriptionListItemDestinationTypeSmsIBMConst  = "sms_ibm"
	SubscriptionListItemDestinationTypeWebhookConst = "webhook"
)

// UnmarshalSubscriptionListItem unmarshals an instance of SubscriptionListItem from the specified map of raw messages.
func UnmarshalSubscriptionListItem(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SubscriptionListItem)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "description", &obj.Description)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "destination_id", &obj.DestinationID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "destination_name", &obj.DestinationName)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "destination_type", &obj.DestinationType)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "topic_id", &obj.TopicID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "topic_name", &obj.TopicName)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "updated_at", &obj.UpdatedAt)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SubscriptionUpdateAttributes : SubscriptionUpdateAttributes struct
// Models which "extend" this model:
// - SubscriptionUpdateAttributesSmsAttributes
// - SubscriptionUpdateAttributesEmailAttributes
// - SubscriptionUpdateAttributesWebhookAttributes
type SubscriptionUpdateAttributes struct {
	// The phone number to send the SMS to.
	To []string `json:"to,omitempty"`

	// Whether to add the notification payload to the email.
	AddNotificationPayload *bool `json:"add_notification_payload,omitempty"`

	// The email address to reply to.
	ReplyTo *string `json:"reply_to,omitempty"`

	// Signing webhook attributes.
	SigningEnabled *bool `json:"signing_enabled,omitempty"`
}

func (*SubscriptionUpdateAttributes) isaSubscriptionUpdateAttributes() bool {
	return true
}

type SubscriptionUpdateAttributesIntf interface {
	isaSubscriptionUpdateAttributes() bool
}

// UnmarshalSubscriptionUpdateAttributes unmarshals an instance of SubscriptionUpdateAttributes from the specified map of raw messages.
func UnmarshalSubscriptionUpdateAttributes(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SubscriptionUpdateAttributes)
	err = core.UnmarshalPrimitive(m, "to", &obj.To)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "add_notification_payload", &obj.AddNotificationPayload)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "reply_to", &obj.ReplyTo)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "signing_enabled", &obj.SigningEnabled)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// Topic : Topic object.
type Topic struct {
	// Autogenerated topic ID.
	ID *string `json:"id" validate:"required"`

	// Description of the topic.
	Description *string `json:"description" validate:"required"`

	// Name of the topic.
	Name *string `json:"name" validate:"required"`

	// Last time the topic was updated.
	UpdatedAt *string `json:"updated_at" validate:"required"`

	// Number of sources.
	SourceCount *int64 `json:"source_count" validate:"required"`

	// List of sources.
	Sources []TopicSourcesItem `json:"sources" validate:"required"`

	// Number of subscriptions.
	SubscriptionCount *int64 `json:"subscription_count" validate:"required"`

	// List of subscriptions.
	Subscriptions []SubscriptionListItem `json:"subscriptions" validate:"required"`
}

// UnmarshalTopic unmarshals an instance of Topic from the specified map of raw messages.
func UnmarshalTopic(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(Topic)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "description", &obj.Description)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "updated_at", &obj.UpdatedAt)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "source_count", &obj.SourceCount)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "sources", &obj.Sources, UnmarshalTopicSourcesItem)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "subscription_count", &obj.SubscriptionCount)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "subscriptions", &obj.Subscriptions, UnmarshalSubscriptionListItem)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// TopicList : Topic list object.
type TopicList struct {
	// Number of topics.
	TotalCount *int64 `json:"total_count" validate:"required"`

	// Current offset.
	Offset *int64 `json:"offset" validate:"required"`

	// limit to show subscriptions.
	Limit *int64 `json:"limit" validate:"required"`

	// List of topics.
	Topics []TopicsListItem `json:"topics" validate:"required"`
}

// UnmarshalTopicList unmarshals an instance of TopicList from the specified map of raw messages.
func UnmarshalTopicList(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(TopicList)
	err = core.UnmarshalPrimitive(m, "total_count", &obj.TotalCount)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "offset", &obj.Offset)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "limit", &obj.Limit)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "topics", &obj.Topics, UnmarshalTopicsListItem)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// TopicResponse : Topic object.
type TopicResponse struct {
	// Autogenerated topic ID.
	ID *string `json:"id" validate:"required"`

	// Name of the topic.
	Name *string `json:"name" validate:"required"`

	// Description of the topic.
	Description *string `json:"description" validate:"required"`

	// Last time the topic was updated.
	CreatedAt *string `json:"created_at" validate:"required"`
}

// UnmarshalTopicResponse unmarshals an instance of TopicResponse from the specified map of raw messages.
func UnmarshalTopicResponse(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(TopicResponse)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "description", &obj.Description)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "created_at", &obj.CreatedAt)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// TopicSourcesItem : TopicSourcesItem struct
type TopicSourcesItem struct {
	// ID of the source.
	ID *string `json:"id" validate:"required"`

	// Name of the source.
	Name *string `json:"name" validate:"required"`

	// List of rules.
	Rules []RulesGet `json:"rules" validate:"required"`
}

// UnmarshalTopicSourcesItem unmarshals an instance of TopicSourcesItem from the specified map of raw messages.
func UnmarshalTopicSourcesItem(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(TopicSourcesItem)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "rules", &obj.Rules, UnmarshalRulesGet)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// TopicUpdateSourcesItem : TopicUpdateSourcesItem struct
type TopicUpdateSourcesItem struct {
	// ID of the source.
	ID *string `json:"id" validate:"required"`

	// List of rules.
	Rules []Rules `json:"rules" validate:"required"`
}

// NewTopicUpdateSourcesItem : Instantiate TopicUpdateSourcesItem (Generic Model Constructor)
func (*EventNotificationsV1) NewTopicUpdateSourcesItem(id string, rules []Rules) (_model *TopicUpdateSourcesItem, err error) {
	_model = &TopicUpdateSourcesItem{
		ID:    core.StringPtr(id),
		Rules: rules,
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

// UnmarshalTopicUpdateSourcesItem unmarshals an instance of TopicUpdateSourcesItem from the specified map of raw messages.
func UnmarshalTopicUpdateSourcesItem(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(TopicUpdateSourcesItem)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "rules", &obj.Rules, UnmarshalRules)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// TopicsListItem : Topic list item object.
type TopicsListItem struct {
	// Autogenerated topic ID.
	ID *string `json:"id" validate:"required"`

	// Name of the topic.
	Name *string `json:"name" validate:"required"`

	// Description of the topic.
	Description *string `json:"description" validate:"required"`

	// Number of sources.
	SourceCount *int64 `json:"source_count" validate:"required"`

	// List of source names.
	SourcesNames []string `json:"sources_names" validate:"required"`

	// Number of subscriptions.
	SubscriptionCount *int64 `json:"subscription_count" validate:"required"`
}

// UnmarshalTopicsListItem unmarshals an instance of TopicsListItem from the specified map of raw messages.
func UnmarshalTopicsListItem(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(TopicsListItem)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "description", &obj.Description)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "source_count", &obj.SourceCount)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "sources_names", &obj.SourcesNames)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "subscription_count", &obj.SubscriptionCount)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// UpdateDestinationOptions : The UpdateDestination options.
type UpdateDestinationOptions struct {
	// Unique identifier for IBM Cloud Event Notifications instance.
	InstanceID *string `json:"instance_id" validate:"required,ne="`

	// Unique identifier for Destination.
	ID *string `json:"id" validate:"required,ne="`

	// Destination name.
	Name *string `json:"name,omitempty"`

	// Destination description.
	Description *string `json:"description,omitempty"`

	// Payload describing a destination configuration.
	Config *DestinationConfig `json:"config,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewUpdateDestinationOptions : Instantiate UpdateDestinationOptions
func (*EventNotificationsV1) NewUpdateDestinationOptions(instanceID string, id string) *UpdateDestinationOptions {
	return &UpdateDestinationOptions{
		InstanceID: core.StringPtr(instanceID),
		ID:         core.StringPtr(id),
	}
}

// SetInstanceID : Allow user to set InstanceID
func (_options *UpdateDestinationOptions) SetInstanceID(instanceID string) *UpdateDestinationOptions {
	_options.InstanceID = core.StringPtr(instanceID)
	return _options
}

// SetID : Allow user to set ID
func (_options *UpdateDestinationOptions) SetID(id string) *UpdateDestinationOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetName : Allow user to set Name
func (_options *UpdateDestinationOptions) SetName(name string) *UpdateDestinationOptions {
	_options.Name = core.StringPtr(name)
	return _options
}

// SetDescription : Allow user to set Description
func (_options *UpdateDestinationOptions) SetDescription(description string) *UpdateDestinationOptions {
	_options.Description = core.StringPtr(description)
	return _options
}

// SetConfig : Allow user to set Config
func (_options *UpdateDestinationOptions) SetConfig(config *DestinationConfig) *UpdateDestinationOptions {
	_options.Config = config
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *UpdateDestinationOptions) SetHeaders(param map[string]string) *UpdateDestinationOptions {
	options.Headers = param
	return options
}

// UpdateSubscriptionOptions : The UpdateSubscription options.
type UpdateSubscriptionOptions struct {
	// Unique identifier for IBM Cloud Event Notifications instance.
	InstanceID *string `json:"instance_id" validate:"required,ne="`

	// Unique identifier for Subscription.
	ID *string `json:"id" validate:"required,ne="`

	// Name of the subscription.
	Name *string `json:"name,omitempty"`

	// Description of the subscription.
	Description *string `json:"description,omitempty"`

	Attributes SubscriptionUpdateAttributesIntf `json:"attributes,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewUpdateSubscriptionOptions : Instantiate UpdateSubscriptionOptions
func (*EventNotificationsV1) NewUpdateSubscriptionOptions(instanceID string, id string) *UpdateSubscriptionOptions {
	return &UpdateSubscriptionOptions{
		InstanceID: core.StringPtr(instanceID),
		ID:         core.StringPtr(id),
	}
}

// SetInstanceID : Allow user to set InstanceID
func (_options *UpdateSubscriptionOptions) SetInstanceID(instanceID string) *UpdateSubscriptionOptions {
	_options.InstanceID = core.StringPtr(instanceID)
	return _options
}

// SetID : Allow user to set ID
func (_options *UpdateSubscriptionOptions) SetID(id string) *UpdateSubscriptionOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetName : Allow user to set Name
func (_options *UpdateSubscriptionOptions) SetName(name string) *UpdateSubscriptionOptions {
	_options.Name = core.StringPtr(name)
	return _options
}

// SetDescription : Allow user to set Description
func (_options *UpdateSubscriptionOptions) SetDescription(description string) *UpdateSubscriptionOptions {
	_options.Description = core.StringPtr(description)
	return _options
}

// SetAttributes : Allow user to set Attributes
func (_options *UpdateSubscriptionOptions) SetAttributes(attributes SubscriptionUpdateAttributesIntf) *UpdateSubscriptionOptions {
	_options.Attributes = attributes
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *UpdateSubscriptionOptions) SetHeaders(param map[string]string) *UpdateSubscriptionOptions {
	options.Headers = param
	return options
}

// DestinationConfigParamsWebhookDestinationConfig : Payload describing a webhook destination configuration.
// This model "extends" DestinationConfigParams
type DestinationConfigParamsWebhookDestinationConfig struct {
	// URL of webhook.
	URL *string `json:"url" validate:"required"`

	// HTTP method of webhook.
	Verb *string `json:"verb" validate:"required"`

	// Custom headers (Key-Value pair) for webhook call.
	CustomHeaders map[string]string `json:"custom_headers,omitempty"`

	// List of sensitive headers from custom headers.
	SensitiveHeaders []string `json:"sensitive_headers,omitempty"`
}

// Constants associated with the DestinationConfigParamsWebhookDestinationConfig.Verb property.
// HTTP method of webhook.
const (
	DestinationConfigParamsWebhookDestinationConfigVerbGetConst  = "get"
	DestinationConfigParamsWebhookDestinationConfigVerbPostConst = "post"
)

// NewDestinationConfigParamsWebhookDestinationConfig : Instantiate DestinationConfigParamsWebhookDestinationConfig (Generic Model Constructor)
func (*EventNotificationsV1) NewDestinationConfigParamsWebhookDestinationConfig(url string, verb string) (_model *DestinationConfigParamsWebhookDestinationConfig, err error) {
	_model = &DestinationConfigParamsWebhookDestinationConfig{
		URL:  core.StringPtr(url),
		Verb: core.StringPtr(verb),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*DestinationConfigParamsWebhookDestinationConfig) isaDestinationConfigParams() bool {
	return true
}

// UnmarshalDestinationConfigParamsWebhookDestinationConfig unmarshals an instance of DestinationConfigParamsWebhookDestinationConfig from the specified map of raw messages.
func UnmarshalDestinationConfigParamsWebhookDestinationConfig(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(DestinationConfigParamsWebhookDestinationConfig)
	err = core.UnmarshalPrimitive(m, "url", &obj.URL)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "verb", &obj.Verb)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "custom_headers", &obj.CustomHeaders)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "sensitive_headers", &obj.SensitiveHeaders)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SubscriptionAttributesEmailAttributesResponse : The attributes for an email notification.
// This model "extends" SubscriptionAttributes
type SubscriptionAttributesEmailAttributesResponse struct {
	// The email id string.
	To []string `json:"to" validate:"required"`

	// Whether to add the notification payload to the email.
	AddNotificationPayload *bool `json:"add_notification_payload" validate:"required"`

	// The email address to reply to.
	ReplyTo *string `json:"reply_to" validate:"required"`

	// The recipient selection method.
	RecipientSelection *string `json:"recipient_selection" validate:"required"`
}

func (*SubscriptionAttributesEmailAttributesResponse) isaSubscriptionAttributes() bool {
	return true
}

// UnmarshalSubscriptionAttributesEmailAttributesResponse unmarshals an instance of SubscriptionAttributesEmailAttributesResponse from the specified map of raw messages.
func UnmarshalSubscriptionAttributesEmailAttributesResponse(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SubscriptionAttributesEmailAttributesResponse)
	err = core.UnmarshalPrimitive(m, "to", &obj.To)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "add_notification_payload", &obj.AddNotificationPayload)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "reply_to", &obj.ReplyTo)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "recipient_selection", &obj.RecipientSelection)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SubscriptionAttributesSmsAttributesResponse : SMS attributes object.
// This model "extends" SubscriptionAttributes
type SubscriptionAttributesSmsAttributesResponse struct {
	// The phone number to send the SMS to.
	To []string `json:"to" validate:"required"`

	// The recipient selection method.
	RecipientSelection *string `json:"recipient_selection" validate:"required"`
}

func (*SubscriptionAttributesSmsAttributesResponse) isaSubscriptionAttributes() bool {
	return true
}

// UnmarshalSubscriptionAttributesSmsAttributesResponse unmarshals an instance of SubscriptionAttributesSmsAttributesResponse from the specified map of raw messages.
func UnmarshalSubscriptionAttributesSmsAttributesResponse(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SubscriptionAttributesSmsAttributesResponse)
	err = core.UnmarshalPrimitive(m, "to", &obj.To)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "recipient_selection", &obj.RecipientSelection)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SubscriptionAttributesWebhookAttributesResponse : The attributes for a webhook notification.
// This model "extends" SubscriptionAttributes
type SubscriptionAttributesWebhookAttributesResponse struct {
	// Signing webhook attributes.
	SigningEnabled *bool `json:"signing_enabled" validate:"required"`

	// Decision for Notification Payload to be added.
	AddNotificationPayload *bool `json:"add_notification_payload" validate:"required"`
}

func (*SubscriptionAttributesWebhookAttributesResponse) isaSubscriptionAttributes() bool {
	return true
}

// UnmarshalSubscriptionAttributesWebhookAttributesResponse unmarshals an instance of SubscriptionAttributesWebhookAttributesResponse from the specified map of raw messages.
func UnmarshalSubscriptionAttributesWebhookAttributesResponse(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SubscriptionAttributesWebhookAttributesResponse)
	err = core.UnmarshalPrimitive(m, "signing_enabled", &obj.SigningEnabled)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "add_notification_payload", &obj.AddNotificationPayload)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SubscriptionCreateAttributesEmailAttributes : The attributes for an email notification.
// This model "extends" SubscriptionCreateAttributes
type SubscriptionCreateAttributesEmailAttributes struct {
	// The email id string.
	To []string `json:"to" validate:"required"`

	// Whether to add the notification payload to the email.
	AddNotificationPayload *bool `json:"add_notification_payload" validate:"required"`

	// The email address to reply to.
	ReplyTo *string `json:"reply_to,omitempty"`
}

// NewSubscriptionCreateAttributesEmailAttributes : Instantiate SubscriptionCreateAttributesEmailAttributes (Generic Model Constructor)
func (*EventNotificationsV1) NewSubscriptionCreateAttributesEmailAttributes(to []string, addNotificationPayload bool) (_model *SubscriptionCreateAttributesEmailAttributes, err error) {
	_model = &SubscriptionCreateAttributesEmailAttributes{
		To:                     to,
		AddNotificationPayload: core.BoolPtr(addNotificationPayload),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*SubscriptionCreateAttributesEmailAttributes) isaSubscriptionCreateAttributes() bool {
	return true
}

// UnmarshalSubscriptionCreateAttributesEmailAttributes unmarshals an instance of SubscriptionCreateAttributesEmailAttributes from the specified map of raw messages.
func UnmarshalSubscriptionCreateAttributesEmailAttributes(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SubscriptionCreateAttributesEmailAttributes)
	err = core.UnmarshalPrimitive(m, "to", &obj.To)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "add_notification_payload", &obj.AddNotificationPayload)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "reply_to", &obj.ReplyTo)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SubscriptionCreateAttributesSmsAttributes : SMS attributes object.
// This model "extends" SubscriptionCreateAttributes
type SubscriptionCreateAttributesSmsAttributes struct {
	// The phone number to send the SMS to.
	To []string `json:"to" validate:"required"`
}

// NewSubscriptionCreateAttributesSmsAttributes : Instantiate SubscriptionCreateAttributesSmsAttributes (Generic Model Constructor)
func (*EventNotificationsV1) NewSubscriptionCreateAttributesSmsAttributes(to []string) (_model *SubscriptionCreateAttributesSmsAttributes, err error) {
	_model = &SubscriptionCreateAttributesSmsAttributes{
		To: to,
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*SubscriptionCreateAttributesSmsAttributes) isaSubscriptionCreateAttributes() bool {
	return true
}

// UnmarshalSubscriptionCreateAttributesSmsAttributes unmarshals an instance of SubscriptionCreateAttributesSmsAttributes from the specified map of raw messages.
func UnmarshalSubscriptionCreateAttributesSmsAttributes(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SubscriptionCreateAttributesSmsAttributes)
	err = core.UnmarshalPrimitive(m, "to", &obj.To)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SubscriptionCreateAttributesWebhookAttributes : The attributes for a webhook notification.
// This model "extends" SubscriptionCreateAttributes
type SubscriptionCreateAttributesWebhookAttributes struct {
	// Signing webhook attributes.
	SigningEnabled *bool `json:"signing_enabled" validate:"required"`
}

// NewSubscriptionCreateAttributesWebhookAttributes : Instantiate SubscriptionCreateAttributesWebhookAttributes (Generic Model Constructor)
func (*EventNotificationsV1) NewSubscriptionCreateAttributesWebhookAttributes(signingEnabled bool) (_model *SubscriptionCreateAttributesWebhookAttributes, err error) {
	_model = &SubscriptionCreateAttributesWebhookAttributes{
		SigningEnabled: core.BoolPtr(signingEnabled),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*SubscriptionCreateAttributesWebhookAttributes) isaSubscriptionCreateAttributes() bool {
	return true
}

// UnmarshalSubscriptionCreateAttributesWebhookAttributes unmarshals an instance of SubscriptionCreateAttributesWebhookAttributes from the specified map of raw messages.
func UnmarshalSubscriptionCreateAttributesWebhookAttributes(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SubscriptionCreateAttributesWebhookAttributes)
	err = core.UnmarshalPrimitive(m, "signing_enabled", &obj.SigningEnabled)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SubscriptionUpdateAttributesEmailAttributes : The attributes for an email notification.
// This model "extends" SubscriptionUpdateAttributes
type SubscriptionUpdateAttributesEmailAttributes struct {
	// The email id string.
	To []string `json:"to" validate:"required"`

	// Whether to add the notification payload to the email.
	AddNotificationPayload *bool `json:"add_notification_payload" validate:"required"`

	// The email address to reply to.
	ReplyTo *string `json:"reply_to,omitempty"`
}

// NewSubscriptionUpdateAttributesEmailAttributes : Instantiate SubscriptionUpdateAttributesEmailAttributes (Generic Model Constructor)
func (*EventNotificationsV1) NewSubscriptionUpdateAttributesEmailAttributes(to []string, addNotificationPayload bool) (_model *SubscriptionUpdateAttributesEmailAttributes, err error) {
	_model = &SubscriptionUpdateAttributesEmailAttributes{
		To:                     to,
		AddNotificationPayload: core.BoolPtr(addNotificationPayload),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*SubscriptionUpdateAttributesEmailAttributes) isaSubscriptionUpdateAttributes() bool {
	return true
}

// UnmarshalSubscriptionUpdateAttributesEmailAttributes unmarshals an instance of SubscriptionUpdateAttributesEmailAttributes from the specified map of raw messages.
func UnmarshalSubscriptionUpdateAttributesEmailAttributes(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SubscriptionUpdateAttributesEmailAttributes)
	err = core.UnmarshalPrimitive(m, "to", &obj.To)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "add_notification_payload", &obj.AddNotificationPayload)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "reply_to", &obj.ReplyTo)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SubscriptionUpdateAttributesSmsAttributes : SMS attributes object.
// This model "extends" SubscriptionUpdateAttributes
type SubscriptionUpdateAttributesSmsAttributes struct {
	// The phone number to send the SMS to.
	To []string `json:"to" validate:"required"`
}

// NewSubscriptionUpdateAttributesSmsAttributes : Instantiate SubscriptionUpdateAttributesSmsAttributes (Generic Model Constructor)
func (*EventNotificationsV1) NewSubscriptionUpdateAttributesSmsAttributes(to []string) (_model *SubscriptionUpdateAttributesSmsAttributes, err error) {
	_model = &SubscriptionUpdateAttributesSmsAttributes{
		To: to,
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*SubscriptionUpdateAttributesSmsAttributes) isaSubscriptionUpdateAttributes() bool {
	return true
}

// UnmarshalSubscriptionUpdateAttributesSmsAttributes unmarshals an instance of SubscriptionUpdateAttributesSmsAttributes from the specified map of raw messages.
func UnmarshalSubscriptionUpdateAttributesSmsAttributes(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SubscriptionUpdateAttributesSmsAttributes)
	err = core.UnmarshalPrimitive(m, "to", &obj.To)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SubscriptionUpdateAttributesWebhookAttributes : The attributes for a webhook notification.
// This model "extends" SubscriptionUpdateAttributes
type SubscriptionUpdateAttributesWebhookAttributes struct {
	// Signing webhook attributes.
	SigningEnabled *bool `json:"signing_enabled" validate:"required"`
}

// NewSubscriptionUpdateAttributesWebhookAttributes : Instantiate SubscriptionUpdateAttributesWebhookAttributes (Generic Model Constructor)
func (*EventNotificationsV1) NewSubscriptionUpdateAttributesWebhookAttributes(signingEnabled bool) (_model *SubscriptionUpdateAttributesWebhookAttributes, err error) {
	_model = &SubscriptionUpdateAttributesWebhookAttributes{
		SigningEnabled: core.BoolPtr(signingEnabled),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*SubscriptionUpdateAttributesWebhookAttributes) isaSubscriptionUpdateAttributes() bool {
	return true
}

// UnmarshalSubscriptionUpdateAttributesWebhookAttributes unmarshals an instance of SubscriptionUpdateAttributesWebhookAttributes from the specified map of raw messages.
func UnmarshalSubscriptionUpdateAttributesWebhookAttributes(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SubscriptionUpdateAttributesWebhookAttributes)
	err = core.UnmarshalPrimitive(m, "signing_enabled", &obj.SigningEnabled)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}
